\chapter{新分割理论的应用}

本章将把分割集的思想应用到程序化简的应用中，并在程序化简里进行扩展，在分割集的思想上找出对程序化简更高效的原子集，并命名为可靠集（$Reliable~Set$）。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{程序化简}

本节将把分割集理论应用到程序化简中。实际上是把程序结论作为分割集应用于程序化简中。本节将定义两个化简操作和程序结论顶部来完成分割集理论在程序化简上的应用，并给出相关的证明。
程序结论中的文字的真值在对应的逻辑程序中的所有回答集里都为真。基于这个确定性，可以把原程序中的一些文字及其所影响的规则删掉，得到一个简化的逻辑程序，并对简化后的逻辑程序进行求解，得到的回答集联合程序结论即可得到原程序的回答集。这就是程序化简后求解逻辑程序的基本思路。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{程序结论与补}

本节将给出程序结论和下一小节的化简操作中需要用到的补的定义。本文所指的程序化简问题即为如何使用程序结论来化简程序。化简后的程序在求解回答集上将比原程序要快得多，因为程序结论将有效地在程序化简过程中把一些已经可以确认真值的文字对程序求解的影响去掉。首先，本文给出程序结论和补的定义。
\begin{definition}[程序结论（$Consequence$）]\label{d_consequence}
	给定正规逻辑程序$P$和一个文字集$L$，如果$L$能被$P$的每个回答集所满足，则称文字集$L$为逻辑程序$P$的一个程序结论（$Consequence$）。
\end{definition}

程序结论的原始定义是面向文字集的，而在只考虑正文字的情况下，文字集可以被视为原子集，下面所涉及的程序结论的使用都将其视为一个原子集。此外，程序结论并不需要在求解出逻辑程序的所有回答集后才能得到，这样也保证了本文使用程序结论的可行性。以下为计算一个程序结论的算法。


接下来，本文给出一个文字集的补（$Complement$）的定义，文字集的补在后续的化简操作符中将被使用。
\begin{definition}[补（$Complement$）]\label{d_complement}
	对于一个文字$l$，其补记为$\overline{l}$。其中，若$l$为$a$形式的正文字，则$\overline{l}$为$\neg a$，若$l$为$\neg a$形式的负文字，则$\overline{l}$为$a$。对于一个文字集$L$，其补定义为：$\overline{L} = \{ \overline{l}~|~l \in L \}$。
\end{definition}

在有了程序结论和文字集的补的定义后，下一小节基于这两个概念定义了两个化简操作，这两个化简操作是程序化简的基础。



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{两个化简操作符}

基于程序结论中的文字的真值确定性，本小节定义两个基于程序结论去简化逻辑程序的化简操作符。它们为原逻辑程序删去受程序结论影响的文字和规则。下面将给出这两个化简操作符的具体的定义，以及给出对它们有效性和合理性的证明。
\begin{definition}[负文字简化]\label{d_tr_n}
	给定逻辑程序$P$和它的一个程序结论$L$，$P$基于$L$中负文字的化简记为$tr_n(P,L)$。$tr_n(P,L)$通过对原逻辑程序$P$执行以下两步操作得到：
	\begin{itemize}
		\item 若$P$中的一个规则$r$中存在原子$p \in body^+(r)$，且有$\neg p \in L$，则从$P$中删去$r$；
		\item 若$P$中的一个规则$r$中存在原子$p \in head(r)$或$p \in body^-(r)$，且有$\neg p \in L$，则把该规则$r$替换为以下形式：
		\begin{equation}
			head(r) \backslash \overline{L}~\leftarrow~body^+(r),~body^-(r) \backslash \overline{L}
		\end{equation}
	\end{itemize}
\end{definition}

\begin{definition}[正文字]\label{d_tr_p}
	给定逻辑程序$P$和它的一个程序结论$L$，$P$基于$L$中正文字的化简记为$tr_p(P,L)$。$tr_p(P,L)$通过对原逻辑程序$P$执行以下两步操作得到：
	\begin{itemize}
		\item 若$P$中的一个规则$r$中存在原子$p \in head(r)$或$p \in body^-(r)$，且有$p \in L$，则从$P$中删去$r$；
		\item 若$P$中的一个规则$r$中存在原子$p \in body^+(r)$，且有$p \in L$，则把该规则$r$替换为以下形式：
		\begin{equation}
			head(r)~\leftarrow~body^+(r) \backslash L,~body^-(r)
		\end{equation}
	\end{itemize}
\end{definition}

接下来本文给出关于上述两个定义的合理性和正确性的证明。
\begin{proof}
	对于负文字化简$tr_n(P,L)$，其只考虑程序结论$L$中的负文字，即满足$\neg p \in L$的原子$p$。在$\neg p \in L$时，基于程序结论的定义性质，可以得到推不出$p$为真，所以得到$p$为假，$not~p$为真。对于$tr_n(P,L)$的两个步骤有：
	\begin{enumerate}
		\item 若$p \in body^+(r)$，且规则体部文字为合取关系。对于一个合取式$A \land B \land C$，若可以确定$C \equiv false$，那么有$A \land B \land C \equiv false$。所以在可以确定$p$为假的情况下，则可以确定$body(r)$为假，故这样的体部无法推出头部，进而可以把这个规则删掉。
		\item 若$p \in head(r)$，且规则头部文字为析取关系。对于一个析取式$A \lor B \lor C$，若可以确定$C \equiv false$，那么有$A \lor B \lor C \equiv A \lor B$。所以在可以确定$p$为假的情况下，可以从$head(r)$中删掉$p$。若$p \in body^-(r)$，且规则体部文字为合取关系。对于一个合取式$A \land B \land C$，若可以确定$C \equiv true$，那么有$A \land B \land C \equiv A \land B$。所以在可以确定$not~p$为真的情况下，则可以确定$body^-(r)$删去$p$。所以$tr_n(P,L)$的第二步把符合要求的规则替换为$head(r) \backslash \overline{L}~\leftarrow~body^+(r),~body^-(r) \backslash \overline{L}$。
	\end{enumerate}
	
	对于正文字化简$tr_p(P,L)$，其只考虑程序结论$L$中的正文字，即满足$p \in L$的原子$p$。在$p \in L$时，基于程序结论的定义性质，可以推出$p$为真，$not~p$为假。对于$tr_p(P,L)$的两个步骤有：
	\begin{enumerate}
		\item 若$p \in head(r)$，且规则头部文字为析取关系。对于一个析取式$A \lor B \lor C$，若可以确定$C \equiv true$，那么有$A \lor B \lor C \equiv true$。所以在可以确定$p$为真的情况下，则可以确定$head(r)$为真，故此规则无须考虑，可以删去。若$p \in body^-(r)$，且规则体部文字为合取关系。对于一个合取式$A \land B \land C$，若可以确定$C \equiv false$，那么有$A \land B \land C \equiv false$。所以在可以确定$not~p$为假的情况下，则$body(r)$为假，无法推出结论，故可以删去此规则。
		\item 若$p \in body^+(r)$，且规则体部文字为合取关系。对于一个合取式$A \land B \land C$，若可以确定$C \equiv true$，那么有$A \land B \land C \equiv A \land B$。所以在可以确定$not~p$为真的情况下，则可以确定$body^+(r)$删去$p$。所以$tr_p(P,L)$的第二步把符合要求的规则替换为$head(r)~\leftarrow~body^+(r) \backslash L,~body^-(r)$。
	\end{enumerate}
	
	综上所述，定义\ref{d_tr_n}和\ref{d_tr_p}中的基于程序结论中文字的真值特性所定义的正负文字化简操作符是合理而且有效的。\quad
\end{proof}

根据正文字化简和负文字化简操作符的定义可以知道给定一个逻辑程序$P$和它的一个程序结论$L$，$tr_n(P,L)$得到的逻辑程序中将不含任何满足$\neg p \in L$的原子$p$。同理，$tr_p(P,L)$得到的逻辑程序中将不含任何满足$p \in L$的原子$p$。那么$tr_p(tr_n(P,L),L)$得到的逻辑程序中将不含任何满足$p \in Atoms(L)$的原子$p$。

对于一个逻辑程序$P$，$tr_p(tr_n(P,L),L)$使得$P$基于它的程序结论$L$把已经可以确定真值的文字及这些文字对$P$的影响移除。这个操作的实质效果便是：在已知一部分回答集（即程序结论）的情况下，去掉这部分对逻辑程序P的影响，在剩下的部分里求解出余下的回答集部分。这个过程跟程序分割通过底部求解出$X$，代入顶部求解出剩下的回答集部分$Y$是一致的。

Van和Gelder等人在1991年提出的正规逻辑程序的良序模型（$Well-founded~Model$）\cite{van1991well}也是正规逻辑程序的一个程序结论。当前的主要ASP求解器都内置地使用了良序模型去化简程序。但存在其他比良序模型的基要大的程序结论，而使用这些程序结论将比良序模型更有效地化简程序。明显地，程序结论的基越大，能消去的确定性的的文字越多，程序规模越小，求解越快。Chen，Ji和Lin在2013年时提出了通过使用最多只有一个外部支持的环的环公式去计算程序结论，将有效地得到比良序模型的基要大的程序结论\cite{chen2013computing}。

事实上，$tr_n(P,L)$和$tr_p(P,L)$两者虽然只是根据程序结论中的不同类型的文字（负/正）去化简逻辑程序，但两者的适用性并不完全一致。具体情况将由下面的命题带出。
\begin{proposition}\label{p_4_1}
	给定逻辑程序$P$，文字集$L$是$P$的一个程序结论，那么有：
	\begin{itemize}
		\item 一个原子集$S$是逻辑程序$P$的回答集当且仅当$S$是$tr_n(P,L)$的一个回答集；
		\item 一个原子集$S$是逻辑程序$P$的回答集可以推出$S \backslash L$是$tr_p(P,L)$的一个回答集，但反之不然。
	\end{itemize}
\end{proposition}

\begin{example}\label{e_4_1}
	给定逻辑程序$P$如下：
	\begin{eqnarray}
		a~\leftarrow~b.	\\
		c~\leftarrow~a.	\\
		b~\leftarrow~c.	\\
		c~\leftarrow~d.	\\
		a~\leftarrow~f.	\\
		d~\leftarrow~not~e.	\\
		e~\leftarrow~not~d.	\\
		\leftarrow~not~a.	\\
		f~\leftarrow~a.
	\end{eqnarray}
	
	使用本节提供的算法可以算的程序结论$L=\{a,f\}$，并可以计算得到：
	\begin{equation}
		tr_p(P,L) = \{ c.~b~\leftarrow~c.~c~\leftarrow~d.~d~\leftarrow~not~e.~e~\leftarrow~not~d.\}
	\end{equation}
	
	且有程序$P$的回答集为：
	\begin{equation}
		\Gamma (P) = \{ a,b,c,d,f \}
	\end{equation}
	
	及$tr_p(P,L)$的回答集为：
	\begin{equation}
		\Gamma (tr_p(P,L)) = \{ \{ b,c,d \},~\{ b,c,e \} \}
	\end{equation}
	
	其中${a,b,c,d,f} \backslash L = \{b,c,d\} \neq \{b,c,e\} $。
\end{example}

$tr_n(P,L)$和$tr_p(P,L)$从定义上看只是差异在两者对程序结论中文字类型的应用上。但本质上来说，在逻辑程序中删去正负文字的影响是不一样的。具体的原因涉及Lin和Zhao提出的环理论。下面将给出其正确性的具体的证明。
\begin{proof}
	给定逻辑程序$P$，令$E$为$P$中的一个环，$L$为$P$的一个程序结论。
	
	对于命题\ref{p_4_1}中的第一个结论，$E$是$P$中的一个环，但$E$不一定能保持也是$tr_n(P,L)$中的一个环，因为$tr_n(P,L)$中可能删掉某些规则导致环$E$被破坏。然而$tr_n(P,L)$的回答集仍然能满足环$E$的环公式。这是因为$tr_n(P,L)$删去的是程序结论中的负文字及其相关的影响。负文字代表推不出为真的原子，这些原子不会作为任何一个环的外部支持，所以去掉这些相关的文字并不会影响环公式被满足的基本要求。故保证了$tr_n(P,L)$的回答集仍然能满足逻辑程序中所有环的环公式。同时负文字必然不会作为回答集的部分，所以得到第一个结论的正确性。
	
	对于命题\ref{p_4_1}中的第二个结论，$E$是$P$中的一个环，但$E$也不一定能保持也是$tr_p(P,L)$中的一个环，因为$tr_p(P,L)$中同样可能会删去某些正体部的原子导致环$E$被破坏。但由于$tr_p(P,L)$是基于程序结论的正文字进行化简的，会删去这些正文及其影响。而这些正文字可能作为环$E$的外部支持，故当这些正文字被删除后，求解出来的回答集将不满足环$E$的环公式。同时，这些正文字是会出现在原程序的回答集中的，故$S \backslash L$作为$tr_p(P,L)$的回答集时并不一定能保证$S$是原程序的一个回答集，它可能不能满足原程序的所有环公式。\quad
\end{proof}

基于命题\ref{p_4_1}的两个结论，可以知道$tr_n(P,L)$比$tr_p(P,L)$的泛用性更好。然而$tr_p(P,L)$使用的程序结论中的正文字才更有意义，因为这部分将是原程序回答集中的内容。所以本文后续将顺着需要满足所有环公式的思路去设计能让$tr_p(P,L)$泛化的操作符。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{程序化简操作}

本节将提出使用程序结论去分割逻辑程序，并对分割出来的结论顶部（$Consequence~Top$）进行$tr_p(P,L)$化简，并给出一个$tr_p(P,L)$具有泛用性的命题结论。

对于一个逻辑程序$P$及其一个程序结论$U$，本节将使用$U$去分割$P$以得到一个不含$U$中任何原子的新逻辑程序，再使用$tr_p(P,L)$对新的逻辑程序进行化简，求解回答集，以得到原程序的实际回答集。首先，本节给出后续需要用到的相关定义。
\begin{definition}\label{new_in_U_P}
	给定逻辑程序$P$及其程序结论$U$，标记与$U$无关的规则集合为$in'_U(P)$，且有：
	\begin{equation}
		in'_U(P) = \{ r \in P~|~head(r) \cap U \neq \emptyset,~Atoms(r) \nsubseteq U \}
	\end{equation}
\end{definition}

\begin{definition}\label{C_S_U_P}
	给定逻辑程序$P$及其程序结论$U$，标记$P$基于$U$的结论半环（$Consequence~Semi-Loop$）为$CS_U(P)$，且有：
	\begin{equation}
		CS_U(P) = \{ E~|~E \subseteq U,~E \neq \emptyset,~R^-(E,P) \subseteq in'_U(P) \}
	\end{equation}
\end{definition}

\begin{definition}[结论顶部（$Consequence~Top$）]\label{consequence_top}
	给定逻辑程序$P$及其程序结论$U$，标记$P$基于$U$的结论顶部为$ct_U(P)$，并由以下四部分的并集组成：
	\begin{itemize}
		\item $P \backslash (b_U(P) \cup out_U(P)$，
		\item $\{ \{x_E\} \cup head(r) \backslash E~\leftarrow~body(r)~|~r \in in_U(P)~and~r \in R^-(E,P,X) \},~for~each~E \in CS_U(P,X)$，
		\item $\{ head(r)~\leftarrow~x_{E_1},x_{E_2},...,x_{E_t},body(r)~|~r \in out_U(P),~for~all~possible~E_i \in CS_U(P,X)(1 \leq i \leq t)~s.t.~body^+(r) \cap E_i \neq \emptyset \}$，
		\item $\{ \leftarrow~not~x_E \},~for~each~E \in CS_U(P)$。
	\end{itemize}
\end{definition}

结论顶部的设计跟析取逻辑程序的顶部类似，其中加入了最后一部分以保证原程序的所有环公式都能被满足。

依此，本文给出使$tr_p(P,L)$具有泛用性的命题结论，并给出相关的证明和例子。注意，这里只考虑只包含正文字的程序结论，所以下面也将程序结论看做一个原子集。
\begin{proposition}\label{p_4_2}
	给定正规逻辑程序$P$和其程序结论$U$，一个原子集$S$是$P$的一个回答集，当且仅当存在$tr_p(ct_U(P),U)$的一个回答集$S*$满足$S \backslash U = S* \cap Atoms(P)$。
\end{proposition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
	lack of\quad
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



在计算复杂性方面，$tr_p(ct_U(P),U)$同样会因为$CS_U(P)$而引入新原子，这里也存在指数爆炸的最坏情况。但类似分割理论中的分析，只要通过限制$|in'_U(P)|$的大小来限制$|CS_U(P)|$的大小，则可以有效地把$tr_p(ct_U(P),U)$的计算变得可以接受。

以下通过一个例子直观地展示命题\ref{p_4_2}的效果。
\begin{example}\label{e_4_2}
	继续使用例\ref{e_4_1}中的逻辑程序，令$U=\{a,f\}$，则根据定义可以计算得到$CS_U(P)=\{\{a,f\}\}$，并有：
	\begin{equation}
		ct_U(P) = \{ b~\leftarrow~c.~c~\leftarrow~d.~d~\leftarrow~not~e.~e~\leftarrow~not~d.~\leftarrow~a.~x_{\{a,f\}}~\leftarrow~b.~c~\leftarrow~x_{\{a,f\}},~a.~\leftarrow~not~x_{\{a,f\}}. \}
	\end{equation}
	
	则有：
	\begin{equation}
		tr_p(ct_U(P),U) = \{ b~\leftarrow~c.~c~\leftarrow~d.~d~\leftarrow~not~e.~e~\leftarrow~not~d.~x_{\{a,f\}}~\leftarrow~b.~c~\leftarrow~x_{\{a,f\}}.~\leftarrow~not~x_{\{a,f\}}. \}
	\end{equation}
	
	通过ASP求解器可以计算得到：
	\begin{equation}
		\Gamma (tr_p(ct_U(P),U) = \{ b,c,d,x_{\{a,f\}} \}
	\end{equation}
	
	则有：
	\begin{equation}
		(\Gamma (tr_p(ct_U(P),U)) \cap Atoms(P)) \cap U = \{ a,b,c,d,f \}
	\end{equation}
	
	结果等于原程序的回答集。
\end{example}

事实上，还能使用通过程序结论找出更具代表性的原子集去化简逻辑程序。下一节将顺着这个思路，给出可靠集的概念，并给出将其应用到程序化简中的理论。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{可靠集}

上一节中提及良序模型（$Well-founded~Model$）被当前主流的ASP求解器用作程序化简的文字集，良序模型本身也是一个程序结论，而Chen和Ji在2013年时就指出一些比良序模型要大的程序结论将能更有效地化简程序。本小节将基于这个思路，找出比良序模型更大的程序结论，并以此进行程序化简，同时将结论扩展到析取逻辑程序。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{可靠集定义及应用}

本小节将给出可靠集的定义，以及其在程序化简上的可用性结论。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{转换算法数据结构}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{翻译模块数据结构}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{主要算法实现}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{解析模块}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{本章小结}

基于第三章翻译理论，本章分模块详细介绍了原型求解器cfo2lp的实现和核心翻译算法。本章设计了一阶限定的问题编码描述，经过解析，再经过限定翻译，输出析取逻辑程序，在使用回答集程序求解器。本章的求解器能够处理一阶稳定理论、一阶并行限定和优先级限定的翻译，并且实现了在后继结构下任意公式的翻译优化算法，即存在量词的消去。

