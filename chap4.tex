\chapter{程序化简}

%本章将把分割集的思想应用到程序化简中，并在程序化简里进行扩展，在分割集的思想上找出对程序化简更高效的原子集，并命名为可靠集（$Reliable~Set$）。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{程序化简}

本章将把分割集理论应用到程序化简中。实际上是把程序结论作为分割集应用于程序化简中。本节将定义两个化简操作和程序结论顶部来完成分割集理论在程序化简上的应用，并给出相关的证明。
程序结论中的文字的真值在对应的逻辑程序中的所有回答集里都为真。基于这个确定性，可以把原程序中的一些文字及其所影响的规则删掉，得到一个简化的逻辑程序，并对简化后的逻辑程序进行求解，得到的回答集联合程序结论即可得到原程序的回答集。这就是程序化简后求解逻辑程序的基本思路。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{程序结论}

本文所指的程序化简问题即为如何使用程序结论来化简程序。化简后的程序在求解回答集上将比原程序要快得多，因为程序结论将有效地在程序化简过程中把一些已经可以确认真值的文字对程序求解的影响去掉。

程序结论的原始定义是面向文字集的，而在只考虑正文字的情况下，文字集可以被视为原子集，下面所涉及的程序结论的使用都将其视为一个原子集。此外，程序结论并不需要在求解出逻辑程序的所有回答集后才能得到，第二章已经给出了相关计算方法\ref{conq_P}。这样也保证了本文使用程序结论的可行性。


基于程序结论和文字集的补的定义，下一小节基于这两个概念定义了两个化简操作，这两个化简操作是程序化简的基础。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{两个化简算子}

基于程序结论中的文字的真值确定性，本节定义两个基于程序结论去简化逻辑程序的化简操作符。它们为原逻辑程序删去受程序结论影响的文字和规则。下面将给出这两个化简操作符的具体的定义，以及给出对它们有效性和合理性的证明。
\begin{definition}[负文字化简]\label{d_tr_n}
	给定逻辑程序$P$和它的一个程序结论$L$，$P$基于$L$中负文字的化简记为$tr_n(P,L)$。$tr_n(P,L)$通过对原逻辑程序$P$执行以下两步操作得到：
	\begin{itemize}
		\item 若$P$中的一个规则$r$中存在原子$p \in body^+(r)$，且有$\neg p \in L$，则从$P$中删去$r$；
		\item 若$P$中的一个规则$r$中存在原子$p \in head(r)$或$p \in body^-(r)$，且有$\neg p \in L$，则把该规则$r$替换为以下形式：
		\begin{equation}
			head(r) \backslash \overline{L}~\leftarrow~body^+(r),~body^-(r) \backslash \overline{L}
		\end{equation}
	\end{itemize}
\end{definition}

\begin{definition}[正文字化简]\label{d_tr_p}
	给定逻辑程序$P$和它的一个程序结论$L$，$P$基于$L$中正文字的化简记为$tr_p(P,L)$。$tr_p(P,L)$通过对原逻辑程序$P$执行以下两步操作得到：
	\begin{itemize}
		\item 若$P$中的一个规则$r$中存在原子$p \in head(r)$或$p \in body^-(r)$，且有$p \in L$，则从$P$中删去$r$；
		\item 若$P$中的一个规则$r$中存在原子$p \in body^+(r)$，且有$p \in L$，则把该规则$r$替换为以下形式：
		\begin{equation}
			head(r)~\leftarrow~body^+(r) \backslash L,~body^-(r)
		\end{equation}
	\end{itemize}
\end{definition}

接下来本文给出关于上述两个定义的合理性和正确性的证明。
\begin{proof}
	对于负文字化简$tr_n(P,L)$，其只考虑程序结论$L$中的负文字，即满足$\neg p \in L$的原子$p$。在$\neg p \in L$时，基于程序结论的定义性质，可以得到推不出$p$为真，所以得到$p$为假，$not~p$为真。对于$tr_n(P,L)$的两个步骤有：
	\begin{enumerate}
		\item 若$p \in body^+(r)$，且规则体部文字为合取关系。对于一个合取式$A \land B \land C$，若可以确定$C \equiv false$，那么有$A \land B \land C \equiv false$。所以在可以确定$p$为假的情况下，则可以确定$body(r)$为假，故这样的体部无法推出头部，进而可以把这个规则删掉。
		\item 若$p \in head(r)$，且规则头部文字为析取关系。对于一个析取式$A \lor B \lor C$，若可以确定$C \equiv false$，那么有$A \lor B \lor C \equiv A \lor B$。所以在可以确定$p$为假的情况下，可以从$head(r)$中删掉$p$。若$p \in body^-(r)$，且规则体部文字为合取关系。对于一个合取式$A \land B \land C$，若可以确定$C \equiv true$，那么有$A \land B \land C \equiv A \land B$。所以在可以确定$not~p$为真的情况下，则可以确定$body^-(r)$删去$p$。所以$tr_n(P,L)$的第二步把符合要求的规则替换为$head(r) \backslash \overline{L}~\leftarrow~body^+(r),~body^-(r) \backslash \overline{L}$。
	\end{enumerate}
	
	对于正文字化简$tr_p(P,L)$，其只考虑程序结论$L$中的正文字，即满足$p \in L$的原子$p$。在$p \in L$时，基于程序结论的定义性质，可以推出$p$为真，$not~p$为假。对于$tr_p(P,L)$的两个步骤有：
	\begin{enumerate}
		\item 若$p \in head(r)$，且规则头部文字为析取关系。对于一个析取式$A \lor B \lor C$，若可以确定$C \equiv true$，那么有$A \lor B \lor C \equiv true$。所以在可以确定$p$为真的情况下，则可以确定$head(r)$为真，故此规则无须考虑，可以删去。若$p \in body^-(r)$，且规则体部文字为合取关系。对于一个合取式$A \land B \land C$，若可以确定$C \equiv false$，那么有$A \land B \land C \equiv false$。所以在可以确定$not~p$为假的情况下，则$body(r)$为假，无法推出结论，故可以删去此规则。
		\item 若$p \in body^+(r)$，且规则体部文字为合取关系。对于一个合取式$A \land B \land C$，若可以确定$C \equiv true$，那么有$A \land B \land C \equiv A \land B$。所以在可以确定$not~p$为真的情况下，则可以确定$body^+(r)$删去$p$。所以$tr_p(P,L)$的第二步把符合要求的规则替换为$head(r)~\leftarrow~body^+(r) \backslash L,~body^-(r)$。
	\end{enumerate}
	
	综上所述，定义\ref{d_tr_n}和\ref{d_tr_p}中的基于程序结论中文字的真值特性所定义的正负文字化简操作符是合理而且有效的。\quad
\end{proof}

根据正文字化简和负文字化简操作符的定义可以知道给定一个逻辑程序$P$和它的一个程序结论$L$，$tr_n(P,L)$得到的逻辑程序中将不含任何满足$\neg p \in L$的原子$p$。同理，$tr_p(P,L)$得到的逻辑程序中将不含任何满足$p \in L$的原子$p$。那么$tr_p(tr_n(P,L),L)$得到的逻辑程序中将不含任何满足$p \in Atoms(L)$的原子$p$。

对于一个逻辑程序$P$，$tr_p(tr_n(P,L),L)$使得$P$基于它的程序结论$L$把已经可以确定真值的文字及这些文字对$P$的影响移除。这个操作的实质效果便是：在已知一部分回答集（即程序结论）的情况下，去掉这部分对逻辑程序P的影响，在剩下的部分里求解出余下的回答集部分。这个过程跟程序分割通过底部求解出$X$，代入顶部求解出剩下的回答集部分$Y$是一致的。

Van和Gelder等人在1991年提出的正规逻辑程序的良序模型（$Well-founded~Model$）\cite{van1991well}也是正规逻辑程序的一个程序结论。当前的主要ASP求解器都内置地使用了良序模型去化简程序。但存在其他比良序模型的基要大的程序结论，而使用这些程序结论将比良序模型更有效地化简程序。明显地，程序结论的基越大，能消去的确定性的的文字越多，程序规模越小，求解越快。Chen，Ji和Lin在2013年时提出了通过使用最多只有一个外部支持的环的环公式去计算程序结论，将有效地得到比良序模型的基要大的程序结论\cite{chen2013computing}。

事实上，$tr_n(P,L)$和$tr_p(P,L)$两者虽然只是根据程序结论中的不同类型的文字（负/正）去化简逻辑程序，但两者的适用性并不完全一致。具体情况将由下面的命题带出。
\begin{proposition}\label{p_4_1}
	给定逻辑程序$P$，文字集$L$是$P$的一个程序结论，那么有：
	\begin{itemize}
		\item 一个原子集$S$是逻辑程序$P$的回答集当且仅当$S$是$tr_n(P,L)$的一个回答集；
		\item 一个原子集$S$是逻辑程序$P$的回答集可以推出$S \backslash L$是$tr_p(P,L)$的一个回答集，但反之不然。
	\end{itemize}
\end{proposition}

\begin{example}\label{e_4_1}
	给定逻辑程序$P$如下：
	\begin{eqnarray}
		a~\leftarrow~b.	\\
		c~\leftarrow~a.	\\
		b~\leftarrow~c.	\\
		c~\leftarrow~d.	\\
		a~\leftarrow~f.	\\
		d~\leftarrow~not~e.	\\
		e~\leftarrow~not~d.	\\
		\leftarrow~not~a.	\\
		f~\leftarrow~a.
	\end{eqnarray}
	
	使用本节提供的算法可以算的程序结论$L=\{a,f\}$，并可以计算得到：
	\begin{equation}
		tr_p(P,L) = \{ c.~b~\leftarrow~c.~c~\leftarrow~d.~d~\leftarrow~not~e.~e~\leftarrow~not~d.\}
	\end{equation}
	
	且有程序$P$的回答集为：
	\begin{equation}
		\Gamma (P) = \{ a,b,c,d,f \}
	\end{equation}
	
	及$tr_p(P,L)$的回答集为：
	\begin{equation}
		\Gamma (tr_p(P,L)) = \{ \{ b,c,d \},~\{ b,c,e \} \}
	\end{equation}
	
	其中${a,b,c,d,f} \backslash L = \{b,c,d\} \neq \{b,c,e\} $。
\end{example}

$tr_n(P,L)$和$tr_p(P,L)$从定义上看只是差异在两者对程序结论中文字类型的应用上。但本质上来说，在逻辑程序中删去正负文字的影响是不一样的。具体的原因涉及Lin和Zhao提出的环理论。下面将给出其正确性的具体的证明。
\begin{proof}
	给定逻辑程序$P$，令$E$为$P$中的一个环，$L$为$P$的一个程序结论。
	
	对于命题\ref{p_4_1}中的第一个结论，$E$是$P$中的一个环，但$E$不一定能保持也是$tr_n(P,L)$中的一个环，因为$tr_n(P,L)$中可能删掉某些规则导致环$E$被破坏。然而$tr_n(P,L)$的回答集仍然能满足环$E$的环公式。这是因为$tr_n(P,L)$删去的是程序结论中的负文字及其相关的影响。负文字代表推不出为真的原子，这些原子不会作为任何一个环的外部支持，所以去掉这些相关的文字并不会影响环公式被满足的基本要求。故保证了$tr_n(P,L)$的回答集仍然能满足逻辑程序中所有环的环公式。同时负文字必然不会作为回答集的部分，所以得到第一个结论的正确性。
	
	对于命题\ref{p_4_1}中的第二个结论，$E$是$P$中的一个环，但$E$也不一定能保持也是$tr_p(P,L)$中的一个环，因为$tr_p(P,L)$中同样可能会删去某些正体部的原子导致环$E$被破坏。但由于$tr_p(P,L)$是基于程序结论的正文字进行化简的，会删去这些正文及其影响。而这些正文字可能作为环$E$的外部支持，故当这些正文字被删除后，求解出来的回答集将不满足环$E$的环公式。同时，这些正文字是会出现在原程序的回答集中的，故$S \backslash L$作为$tr_p(P,L)$的回答集时并不一定能保证$S$是原程序的一个回答集，它可能不能满足原程序的所有环公式。\quad
\end{proof}

基于命题\ref{p_4_1}的两个结论，可以知道$tr_n(P,L)$比$tr_p(P,L)$的泛用性更好。然而$tr_p(P,L)$使用的程序结论中的正文字才更有意义，因为这部分将是原程序回答集中的内容。所以本文后续将顺着需要满足所有环公式的思路去设计能让$tr_p(P,L)$泛化的操作符。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{基于程序结论的程序化简}

本节将提出使用程序结论去分割逻辑程序，并对分割出来的结论顶部（$Consequence~Top$）进行$tr_p(P,L)$化简，并给出一个$tr_p(P,L)$具有泛用性的命题结论。

对于一个逻辑程序$P$及其一个程序结论$U$，本节将使用$U$去分割$P$以得到一个不含$U$中任何原子的新逻辑程序，再使用$tr_p(P,L)$对新的逻辑程序进行化简，求解回答集，以得到原程序的实际回答集。	根据前面的分析可知，$tr_p(P,U)$会因为删去满足$head(r) \in U$及$body^-(r) \cap U \neq \emptyset$的规则$r$。同时，在剩下的规则中删去出现在正体部中的$U$中原子。由于正体部被破坏，这可能会导致原程序中的某些环被破坏。故可以引用分割集中构造$t_U(P,X)$的思想构造新的环以保证化简后的程序的回答集可以满足原程序的所有环公式。首先，本节给出后续需要用到的相关定义。
\begin{definition}\label{new_in_U_P}
	给定逻辑程序$P$及其程序结论$U$，标记与$U$无关的规则集合为$in'_U(P)$，且有：
	\begin{equation}
		in'_U(P) = \{ r \in P~|~head(r) \cap U \neq \emptyset,~Atoms(r) \nsubseteq U \}
	\end{equation}
\end{definition}

\begin{definition}\label{C_S_U_P}
	给定逻辑程序$P$及其程序结论$U$，标记$P$基于$U$的结论半环（$Consequence~Semi-Loop$）为$CS_U(P)$，且有：
	\begin{equation}
		CS_U(P) = \{ E~|~E \subseteq U,~E \neq \emptyset,~R^-(E,P) \subseteq in'_U(P) \}
	\end{equation}
\end{definition}

\begin{definition}[结论顶部（$Consequence~Top$）]\label{consequence_top}
	给定逻辑程序$P$及其程序结论$U$，标记$P$基于$U$的结论顶部为$ct_U(P)$，并由以下四部分的并集组成：
	\begin{itemize}
		\item $P \backslash (b_U(P) \cup out_U(P)$，
		\item $\{ \{x_E\} \cup head(r) \backslash E~\leftarrow~body(r)~|~r \in in_U(P)~and~r \in R^-(E,P,X) \},~for~each~E \in CS_U(P,X)$，
		\item $\{ head(r)~\leftarrow~x_{E_1},x_{E_2},...,x_{E_t},body(r)~|~r \in out_U(P),~for~all~possible~E_i \in CS_U(P,X)(1 \leq i \leq t)~s.t.~body^+(r) \cap E_i \neq \emptyset \}$，
		\item $\{ \leftarrow~not~x_E \},~for~each~E \in CS_U(P)$。
	\end{itemize}
\end{definition}

结论顶部的设计跟析取逻辑程序的顶部类似，其中加入了最后一部分以保证原程序的所有环公式都能被满足。

依此，本文给出使$tr_p(P,L)$具有泛用性的命题结论，并给出相关的证明和例子。注意，这里只考虑只包含正文字的程序结论，所以下面也将程序结论看做一个原子集。
\begin{proposition}\label{p_4_2}
	给定正规逻辑程序$P$和其程序结论$U$，一个原子集$S$是$P$的一个回答集，当且仅当存在$tr_p(ct_U(P),U)$的一个回答集$S*$满足$S \backslash U = S* \cap Atoms(P)$。
\end{proposition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
	%%% 充分性
	$(\Rightarrow) \space$ 即证明若$S^*$为$tr_p(ct_U(P),U)$的回答集，且$S \backslash U = S^* \cap Atoms(P)$，则原子集$S$为$P$的回答集。
	
	根据$ct_U(P)$的定义，使用$CS_U(P)$把$b_U(P)$和$out_U(P)$中的符合条件的规则重新构造。为了构造所有可能被破坏的环，$CS_U(P)$中跟强程序分割方法中的$SS_U(P,X)$类似，也考虑$U$的所有非空子集。因为这时已经没有$bottom$的回答集$X$去满足某些环了。$CS_U(P)$中只剔除了$R^-(E,P)$中有规则$r$满足$Atoms(r) \subseteq U$的$E$，删去该规则不会影响环公式被满足。因为$U$中的原子的真值都为真。若这些原子属于某个环$L$，那么必有$L$中的所有原子均为真，则必有$Atoms(L) \subseteq Atoms(U)$。删去这样的规则$r$不会破坏环。这也是$in'_U(P)$定义的原因。
	
	在$ct_U(P)$中的第二和第三部分中依旧保证为所有可能被破坏的环构造新的环，并加入第四部分$\{ \leftarrow~not~x_E \}$，这也是为了保证被替换成$x_E$的那些原来的原子的真值都为真，因为它们是属于程序结论$U$的。
	
	定义$P_U$如下：
	\begin{equation}
		P_U~=~\{ r \in P~|~Atoms(r) \subseteq U \}
	\end{equation}
	
	则可以知道$U$是$P_U$的回答集。此外，令$S^*$为$tr_p(ct_U(P),U)$的回答集，根据上述对$ct_U(P)$的分析，显然，$S^* \cap Atoms(P)$为$P \backslash P_U$的回答集，所以有$(S^* \cap Atoms(P)) \cup U$为$P$的回答集，所以有$S \backslash U = S^* \cap Atoms(P)$，$S$为$P$的回答集。故充分性得证。
	
	
	
	%%% 必要性
	$(\Leftarrow) \space$ 即证明若$S$为$P$的回答集，则存在$S^*$为$tr_p(ct_U(P),U)$的回答集，且满足$S \backslash U = S^* \cap Atoms(P)$。
	
	$ct_U(P)$的定义可知，$\{ x_E~|~E \in CS_U(P) \} = S^* \backslash Atoms(P)$。且$ct_U(P)$把$Atoms(r) \subseteq U$的规则排除掉，且以$x_E$替代$U$中的原子，所以可以得到$S^* \cap Atoms(P)$为$P \backslash P_U$的回答集。又$U$为$P_U$的回答集，故有$S^* \cap Atoms(P) \cup U$为$P$的回答集。故$S = S^* \cap Atoms(P) \cup U$，所以满足$S \backslash U = S^* \cap Atoms(P)$。故必要性得证。\quad
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






在计算复杂性方面，$tr_p(ct_U(P),U)$同样会因为$CS_U(P)$而引入新原子，这里也存在指数爆炸的最坏情况。但类似分割理论中的分析，只要通过限制$|in'_U(P)|$的大小来限制$|CS_U(P)|$的大小，则可以有效地把$tr_p(ct_U(P),U)$的计算变得可以接受。

以下通过一个例子直观地展示命题\ref{p_4_2}的效果。
\begin{example}\label{e_4_2}
	继续使用例\ref{e_4_1}中的逻辑程序，令$U=\{a,f\}$，则根据定义可以计算得到$CS_U(P)=\{\{a,f\}\}$，并有：
	\begin{equation}
		\begin{array}{rcl}
			ct_U(P) = \{ b~\leftarrow~c.~c~\leftarrow~d.~d~\leftarrow~not~e.~e~\leftarrow~not~d.~\leftarrow~a.\\
			x_{\{a,f\}}~\leftarrow~b.~c~\leftarrow~x_{\{a,f\}},~a.~\leftarrow~not~x_{\{a,f\}}. \}
		\end{array}
	\end{equation}
	
	则有：
	\begin{equation}
		\begin{array}{rcl}
			tr_p(ct_U(P),U) = \{ b~\leftarrow~c.~c~\leftarrow~d.~d~\leftarrow~not~e.~e~\leftarrow~not~d.\\
			x_{\{a,f\}}~\leftarrow~b.~c~\leftarrow~x_{\{a,f\}}.~\leftarrow~not~x_{\{a,f\}}. \}
		\end{array}
	\end{equation}
	
	通过ASP求解器可以计算得到：
	\begin{equation}
		\Gamma (tr_p(ct_U(P),U) = \{ b,c,d,x_{\{a,f\}} \}
	\end{equation}
	
	则有：
	\begin{equation}
		(\Gamma (tr_p(ct_U(P),U)) \cap Atoms(P)) \cap U = \{ a,b,c,d,f \}
	\end{equation}
	
	结果等于原程序的回答集。
\end{example}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{本章小结}



