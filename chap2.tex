\chapter{预备知识}

本章给出了本文将涉及的基础知识，先从命题逻辑进行介绍，引入失败即否定，并定义ASP逻辑程序中的规则，及规则中各个部分涉及的命名符号。然后给出“满足”的概念。完成基础介绍后，进入回答集编程的介绍，包括ASP逻辑程序的回答集语义，并列出一些ASP程序的主要性质，主要是环与环公式，及本文的核心内容分割集与程序分割。

\section{命题逻辑}
命题（$\mathbf{proposition}$）是非真即假的陈述句。我们一般使用字母代表一个命题。命题逻辑由命题公式和一套证明规则所组成，其中命题公式和证明规则就是命题逻辑的运算本体和运算规则\upcite{limo1999lpSAT}。
\begin{definition}\label{proposition_logic}
命题逻辑的符号包括\upcite{luger2003AI}：
\begin{itemize}
	\item 命题符号：$A$，$B$，$C$，...，统称为$\aleph$
	\item 真值符号：$true$，$false$；
	\item 连接词：$\land$，$\lor$，$\neg$，$\rightarrow$，$\equiv$。
\end{itemize}
\end{definition}

在ASP逻辑程序中，我们也把命题符号称为一个原子。
\begin{definition}[文字（$Literal$）\upcite{gelfond1990logic}] \label{literal}
文字就是一个命题符号本身或者一个命题符号的否定。其中一个命题符号本身为正文字，一个命题符号的否定为负文字。
\end{definition}

在逻辑中，否定也称为逻辑补\upcite{gabbay1999negation}。接下来，本文给出一个文字及文字集的补（$Complement$）的定义，文字集的补在后续的化简操作符中将被使用。
\begin{definition}[补（$Complement$）\upcite{gabbay1999negation}] \label{d_complement}
	对于一个文字$l$，其补记为$\overline{l}$。其中，若$l$为$a$形式的正文字，则$\overline{l}$为$\neg a$，若$l$为$\neg a$形式的负文字，则$\overline{l}$为$a$。对于一个文字集$L$，其补定义为：$\overline{L} = \{ \overline{l}~|~l \in L \}$。
\end{definition}

命题的真假性被称为其真值（$Truth~Value$），真值只有真（$true$）和假（$false$）两个。每个命题只能为真或者为假，不能既是真又是假，或者既不是真又不是假\upcite{nuchelmans1973theories}。通常地，在求解逻辑程序中，我们所得到的结果就是指逻辑程序中能被确定真值为真的命题集合。

在定义\ref{proposition_logic}中的连接词的作用是把若干个文字连接成命题公式。每个连接词都有自己的真值表，可以概括如下\upcite{luger2003AI}：
\begin{enumerate}
	\item 非（$\neg$），真假性与其操作的命题相反，当$A$为真时，$\neg A$为假，当$A$为假时，$\neg A$为真；
	\item 合取（$\land$），$A \land B$为真，当且仅当命题$A$和$B$同时为真时；
	\item 析取（$\lor$），$A \lor B$为真，当且仅当命题$A$和$B$中至少有一个为真；
	\item 蕴涵（$\rightarrow$），$A \rightarrow B$为假，当且仅当命题$A$为真且$B$为假。
\end{enumerate}

命题公式由一个文字或者多个文字通过连接词组成。命题公式是命题逻辑的推理基础。在有需要的情况下，命题公式可以通过对合律、德?摩根定律、结合律和分配律等运算性质得到逻辑等价的范式，本文涉及的范式有合取范式和析取范式。

\begin{definition}[范式（$Normal~Form$）] \label{normal_form}
合取范式（$Conjunctive~Normal~Form,~CNF$）：一系列析取式的合取形式；析取范式（$Disjunctive~Normal~Form,~DNF$）：一系列合取式的析取形式；其中析取式（合取式）为若干文字只通过连接词$\lor$（$\land$）进行连接。
\end{definition}




\section{逻辑程序}

早期人工智能的学者都相信可以找到一种以符号演算系统来描述知识和推理过程，以达到模拟人类大脑认知和推理的过程\upcite{steele1990common}。而事实上，逻辑程序便是这样的一种符号演算系统。逻辑程序有多种表达形式。ASP逻辑程序的形式主要便是在经典命题公式中引入失败即否定。

一个ASP逻辑程序一般分为两部分：事实集（$Facts$）和例化（$Grounding$）前的ASP逻辑程序。要求解一个ASP逻辑程序的回答集，需要结合使用事实集和例化前的ASP逻辑程序。

ASP程序的求解过程分为以下两步\upcite{lifschitz2008answer}：
\begin{enumerate}
	\item 先使用例化工具（常用的有$gringo$和$lparse$）通过事实集例化ASP逻辑程序；
	\item 对例化后的ASP逻辑程序，调用求解器（常用的有$clasp$，$smodels$，$ASSAT$和$DLV$）进行求解。
\end{enumerate}

从实际效果来看，例化后的ASP逻辑程序就是不含变量的命题公式集合。本文中只考虑完全例化后的长度有限的ASP逻辑程序。本文所探讨的ASP逻辑程序由有限个规则（$rule$）所组成，其中规则的形式如下：
\begin{equation}\label{asp_rule}
	a_1 \lor a_2 \lor...\lor a_k~\leftarrow~a_{k+1},...,~a_m,~not~a_{m+1},...,~not~a_n.
\end{equation}

其中$n \geq m \geq k \geq 1$，$a_i$为原子（$atom$），$not$代表失败即否定。在$k$，$m$，$n$取不同范围的值时，形式$(\ref{asp_rule})$所表示的规则有不同的意义，具体如下\upcite{lin2004assat}：
\begin{itemize}
	\item $k = 0$时，规则被称为限制（$Constraint$）；
	\item $k = 1$时，规则被称为正规规则（$Normal~Rule$）；
	\item $n = m = 0$时，规则被称为事实（$Fact$）；
	\item $n = m$时，即规则中没有带$not$的原子时，规则称其为正规则（$Positive~Rule$）。
\end{itemize}


\begin{example}\label{first_example_2}
下面为四种形式的规则：
\begin{eqnarray}
	&& \leftarrow~p,~q. \label{rule_1} \\	
	&& r~\leftarrow~s,~not~t. \label{rule_2} \\
	&& s. \label{rule_3}	\\
	&& p~\leftarrow~r,~t.	\label{rule_4} 	\\
	&& s~\lor~p~\leftarrow~r,~t,~not~p. \label{rule_5}
\end{eqnarray}

其中的(\ref{rule_1})为限制，(\ref{rule_2})为正规规则，(\ref{rule_3})为事实，(\ref{rule_4})为正规则，(\ref{rule_5})为一般规则。	
\end{example}


\begin{definition}[正规逻辑程序（$Normal~Logic~Program,~NLP$） \upcite{bonatti2010answer}]
	由有限条正规规则组成的逻辑程序，其中可以包含有限个事实及限制。
\end{definition}

\begin{definition}[析取逻辑程序（$Disjunctive~Logic~Program,~DLP$） \upcite{ben1994propositional}]
	由有限条形如形式(\ref{asp_rule})的规则组成的逻辑程序，其中可以包含有限个事实及限制。
\end{definition}

对于形式(\ref{asp_rule})中的规则，我们还可以将其等价于以下形式：
\begin{equation}\label{head_body_rule}
	head(r)~\leftarrow~body(r).
\end{equation}

其中$r$代表形式(\ref{asp_rule})中的整个规则，$head(r)$称为规则$r$的头部，$body(r)$称为规则$r$的体部。具体有$head(r)$为$a_1 \lor a_2 \lor~...~\lor~a_k$，$body(r)$为$a_{k+1},~...~,~a_m,~not~a_{m+1},~...~,~not~a_n$。其中ASP逻辑程序的头部中的原子连接关系只为析取，体部中的原子连接关系只为合取。更进一步的划分有$body(r)~=~body^+ (r)~\land~body^-(r)$，其中$body^+(r)$为$a_{k+1},~...~,~a_m$，即原规则中不带$not$的文字集合，$body^-(r)$为$not~a_{m+1},~...~,~not~a_n$，即原规则中带有$not$的文字集合。在某些情景下上述定义的命题公式可以被作为原子集（$a~set~of~atoms$）进行讨论。

从集合意义出发，引入以下常用的原子集概念：
\begin{definition}\upcite{lifschitz2002answer}
	定义以下跟一个规则相关的集合，以形式(\ref{asp_rule})中的规则作为例子：	
	\begin{itemize}
		\item $head(r) = \{a_1, a_2, ..., a_k\}$；
		\item $body(r) = \{a_{k+1}, ..., a_m, ..., \neg~a_{m+1},...,\neg~a_n\}$，一个文字集，把体部中的$not$替换为$\neg$而得到；
		\item $body^+(r) = \{a_{k+1},...,a_m\}$，体部正文字的原子组成的原子集；
		\item $body^-(r) = \{a_{m+1},...,a_n\}$，体部负文字的原子组成的原子集；
		\item $Atoms(r) = head(r) \cup body^+(r) \cup body^-(r)$，即规则r中的原子全集。
	\end{itemize}
\end{definition}

给定一个逻辑程序$P$，$P$就是一个规则集合。这里定义$Atoms(P)$即逻辑程序P中所有出现过的原子。
\begin{definition}
	逻辑程序$P$的原子集为：	
	\begin{equation}
		Atoms(P)~=\bigcup_{r \in P}Atoms(r)
	\end{equation}
\end{definition}


\begin{example}
	把例子\ref{first_example_2}中的规则集合看作是一个逻辑程序$P$，对于(\ref{rule_5})则有：
	\begin{eqnarray}
		head(r)=\{s,q\}	\\
		body(r)=\{r,t,p\}	\\
		body^+ (r)=\{r,t\}	\\
		body^-(r)=\{p\}		\\
		Atoms(r)=\{s,q,r,t,p\}
	\end{eqnarray}
	
	同时，$Atoms(P)=\{s,q,r,t,p\}$。
\end{example}

在了解了逻辑程序中涉及的常用概念后，我们将通过满足（$satisfy$）性来定义逻辑程序的模型。
\begin{definition}\upcite{lin2004assat}
	一个原子集$S$满足一个正合取范式$R$，当且仅当$Atoms(R)~\subseteq~S$；一个原子集$S$满足一个正析取范式$R$，当且仅当$Atoms(R)~\cap~S~\neq~\emptyset$。满足符号为$\models$。
\end{definition}

我们把满足的概念放在逻辑程序及其规则中。由于逻辑程序中的头部中的文字为析取关系，且仅有正文字，体部中的文字为合取关系。则相应地定义一个原子集$S$满足一个规则$r$的$body(r)$当且仅当$body^+(r)~\subseteq~S$且$body^-(r)~\cap~S~=~\emptyset$，记为$S~\models~body(r)$。一个原子集$S$满足一个规则$r$的$head(r)$当且仅当$head(r)~\cap~S~\neq~\emptyset$，记为$S~\models~head(r)$\upcite{biere2009handbook}。
\begin{example}
	给定一个原子集$S=\{a,b,c\}$，规则$r1$为$a~\lor~b~\leftarrow~c,~not~d.$，规则$r2$为$d~\lor~e~\leftarrow~c,~not~b.$，则有：$S~\models~head(r1)$，$S~\models~body(r1)$，$S~\nvDash~head(r2)$，$S \nvDash body(r2)$。
\end{example}

接下来，我们定义如何判断一个原子集是否满足一个规则，以及一个原子集是否满足一个逻辑程序。
\begin{definition}\upcite{gelfond1988stable}
	一个原子集$S$满足一个规则$r$，当且仅当$S \models body(r)$蕴涵$S \models head(r)$，并记为$S \models r$。一个原子集$S$满足一个逻辑程序$P$，当且仅当$S$满足$P$中的所有规则。
\end{definition}

\begin{definition}\upcite{gelfond1988stable}
	如果一个原子集$S$满足一个逻辑程序$P$，我们将$S$称为$P$的一个模型（$model$）。若一个原子集$I$是逻辑程序$P$的模型，且不存在另一个原子集$J$符合$J~\subseteq~I$且$J$是逻辑程序$P$的模型，则称原子集$I$是逻辑程序$P$的极小模型（$minimal~model$）。
\end{definition}

\begin{proposition}\upcite{gelfond1988stable}
	一个不包含$not$（失败即否定）的逻辑程序，称为正逻辑程序。正逻辑程序有且仅有一个极小模型。
\end{proposition}


Gelder和Ross等在1991年提出了逻辑程序的良序模型（$Well-founded~Model$）语义\upcite{van1991well}，良序模型需要通过逻辑程序的最大无理集（$Greatest~Unfounded~Set$）来定义。
%% greatest unfounded set
\begin{definition}[无理集（$Unfounded~Set$）\upcite{van1991well} ] \label{unfounded_set}
	给定一个逻辑程序$P$和一个文字集$I$。称原子集$A$为$P$关于$I$的无理集（$Unfounded~Set$），若对$P$中满足$head(r) \in A$的规则$r$，以下其中一个条件成立：
	\begin{itemize}
		\item 存在原子$q \in body(r)$在$I$中为假；
		\item 存在原子$q \in body(r)$属于$A$。
	\end{itemize}
\end{definition}

Gelder和Ross等证明了两个无理集的并集仍然是一个无理集，因此逻辑程序$P$基于文字集$I$存在一个最大无理集（$Greatest~Unfounded~Set$），记为$GUS(P,L)$。
%% Well-founded model
\begin{definition}[良序模型（$Well-Founded~Model$）\upcite{van1991well}] \label{well_founded_model}
	给定逻辑程序$P$和文字集$L$，原子$p \in Atoms(P)$定义$T_P(L)$和$W_P(L)$两个算子：
	\begin{itemize}
		\item $p \in T_P(L)$，当且仅当存在规则$r \in P$满足$head(r) = p$且$L \models body(r)$；
		\item $W_P(L)~=~T_P(L) \cup \neg GUS(P,L)$。
	\end{itemize}
	
	记$WFM(P)$为$W_P(L)$极小不动点，即$WFM(P) = lfp(W_P(L))$，则$WFM(P)$为$P$的良序模型。
\end{definition}


接下来，本文引入回答集编程的语法和语义的相关基础知识。


\section{回答集编程}

\subsection{回答集编程基础}

回答集编程是一种声明式编程，它主要应用于计算复杂性高的搜索问题当中。
在非单调推理的知识表示领域中，回答集编程在知识密集型的应用场景中尤其重要和高效\upcite{zhai2014asp}。
本节将讲述ASP逻辑程序的语义和主要性质，如环和环公式等。

经典逻辑程序只能推出正文字的真值，而实际情况下，我们也需要确定负文字的真值。
Reiter提出的封闭世界假定（$Close~World~Assumption,~CWA$）\upcite{reiter1978closed}和Clark的失败即否定为逻辑程序可以推出负文字形式的结论带来了支持。

失败即否定的基本思想就是：无法证明一个命题为真，则判定其为假。这也是最为自然的一种逻辑假定。
在ASP逻辑程序中一些规则的体部会出现“$not~A$”这样的文字，而对于这个文字，我们可以直观地把它看作是命题:“不能确定$A$为真”，所以如果ASP逻辑程序中不能推出$A$为真，则可以推出$not~A$为真。
实际上，失败即否定描述的是一个文字在逻辑程序中的一致性\upcite{clark1978negation}。
封闭世界假定也是对当前无法确定的事件假定为假。
失败即否定中这种推理过程其实是一种倾向否定的假定逻辑。
即使当前推出$not~A$为真，那是基于暂时无法推出$A$为真。一旦加入可以推出$A$为真的新规则，那么原来的$not~A$则被认为是假\upcite{van1989negation}。
这恰恰是非单调逻辑的本质所在：加入新的结论时可能会推翻之前结论的有效性。

在失败即否定之外，ASP逻辑程序中还引入了经典否定。不过这里说的引入是操作层面上的非语义层面上的\upcite{gelfond1991classical}。ASP逻辑程序中只通过失败即否定的$not$来表示负文字。
对于经典否定，即经典逻辑下的非，ASP逻辑程序通过加入新原子和约束来实现经典否定。

如：为了表示原子$p$的经典否定，可以定义新原子$p\_$，并向原逻辑程序中加入约束“$\leftarrow~p,p\_.$”，保证了$p$和$p\_$不能同时为真。这样就将含有经典否定的逻辑程序转化为不含经典否定的逻辑程序。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
在非单调逻辑的发展过程中，自上世纪七十年代起，主要出现了缺省逻辑（$Default~Logic$）、自认知逻辑（$Auto-epistemic~Logic$）和限定理论（$Circumscription$）\upcite{bonatti2010answer}。然而，这些理论由于缺乏高效的开发工具和不具备模块化程序设计并没有得到广泛应用\upcite{zhai2014asp}。而一直到了1988年，Gelfond和Lifschitz提出了稳定模型语义（$Stable~Model~Semantic$）。稳定模型语义帮助解决了非单调推理无法解释失败即否定的问题。基于稳定模型语义进行的研究和扩展，发展出回答集编程这个领域。

回答集编程所涉及的语法即2.2节中介绍的逻辑程序的内容。现在，我们来介绍回答集编程的语义和主要属性，从ASP逻辑程序的回答集开始。


\subsection{回答集编程的语义}

Gelfond和Lifschitz提出了稳定模型语义（$Stable~Model~Semantic$）时，也给出了一个规约方法，以化简一个ASP逻辑程序中的失败即否定。
\begin{definition}[G-L规约\upcite{gelfond1988stable}]
	给定一个原子集$S$和逻辑程序$P$，$P$基于$S$的G-L规约记为$P^S$。逻辑程序$P$通过以下两个化简规则得到$P^S$：\begin{itemize}
		\item 若一个规则的体部中有$not~p$，且$p \in S$，则删掉该规则；
		\item 对剩下的所有规则，删除体部中的$not~p$，$p$为$Atoms(P)$中任意一个原子。
	\end{itemize}
\end{definition}

\begin{example}
	已知原子集$S=\{a,b,c\}$，且逻辑程序$P$如下：	
	\begin{eqnarray}
		a~\leftarrow~b,~c.	\\
		e~\leftarrow~b,~not~a.  \\
		f~\leftarrow~not~e.
	\end{eqnarray}
	
	根据G-L规约的规则，$P$中第二条规则的负文字中包含$S$里的原子，所以直接删掉；$P$中第三条规则的负文字中包含$S$以外的原子，所以只把负文字删掉。
	
	所以$P^S$为：	
	\begin{eqnarray}
	a~\leftarrow~b,~c.	\\
	f.
	\end{eqnarray}
	
	显然，通过G-L规约进行化简后得到的新逻辑程序$P^S$是一个不包含任何失败即否定的逻辑程序。这样的逻辑程序只有一个唯一的极小的模型，我们称这个模型为稳定模型（$stable~model$），并记其为$\Gamma(P^S)$。
\end{example}


\begin{theorem}
	对于一个不含约束的正规逻辑程序（$NLP~Without~Constraints$） $P$和一个原子集$S$，$S$是$P$的一个回答集（$Answer~Set$）当前仅当$S= \Gamma (P^S)$。
\end{theorem}

对于包含有约束的逻辑程序，我们依旧可以通过G-L规约来定义其回答集，通过对程序中的约束和一般规则分离式判断即可。
\begin{theorem}
对于一个包含约束的正规逻辑程序（$NLP~With~Constraints$）$P$和一个原子集$S$，$S$是$P$的一个回答集（$Answer~Set$）当前仅当$S= \Gamma (PD^S)$，且$S$满足$P$中的所有约束。其中$PD$是$P$去掉所有约束后所得到的逻辑程序。
\end{theorem}

Gefond和Lifschitz在1991年对析取逻辑程序（DLP）的回答集定义进行了补充。关于析取逻辑程序的回答集，依旧可以通过G-L规约得到。对一个析取逻辑程序$P$进行G-L规约后得到的程序记为$P^S$，$P^S$里不再含有$not$，然而不同于正规逻辑程序（NLP），该逻辑程序将有一系列集合意义上的极小模型，这里记为$\Psi (P^S)$。若一个原子集$S$是$\Gamma (P^S)$中的元素，则$S$是逻辑程序$P$的回答集\upcite{gelfond1991classical}。
\begin{theorem}
	给定一个析取逻辑程序$P$和一个原子集$S$，$S$是$P$的一个回答集（$Answer~Set$）当前仅当$S \in \Psi (P^S)$。
\end{theorem}

逻辑程序$P$的所有回答集存在一个交集。
\begin{definition}[程序结论（$Consequence$）\upcite{chen2013computing}] \label{d_consequence}
	给定正规逻辑程序$P$和一个文字集$L$，如果$L$能被$P$的每个回答集所满足，则称文字集$L$为逻辑程序$P$的一个程序结论（$Consequence$）。
\end{definition}

一个逻辑程序$P$的程序结论并不需要求解出所有回答集后才能得到。Chen和Ji在2013年给出了一个计算程序结论的算法\upcite{chen2013computing}。在引入程序结论的计算方法前，先介绍其需要用到的算子。
\begin{definition}[子句（$Clause$）] \label{d_clause} \upcite{Chin1973symbolic}
	在逻辑中，子句即若干个文字的析取。若一个子句中只包含一个文字，则成为单位子句（$Unit~Clause$）。
\end{definition}

把一个逻辑程序$P$中的规则$r$转换成子句就是通过蕴涵式等价为析取式的转换：$p \rightarrow q \equiv \neg p \lor q$。
\begin{definition}[单位传播（$Unit~Propagation$）] \label{unit_propagation} \upcite{zhang1996efficient}
	给定一个子句集$C$，令其中的单位子句集合为$S$，单位传播即对$C \backslash S$中的子句执行以下两步：
	\begin{itemize}
		\item 删去包含$S$中的文字的子句；
		\item 子句中出现的$\neg l$删去，其中$l \in S$。
	\end{itemize}
\end{definition}

Chen和Ji等在2013年给出了一个递归型的计算单位传播的算法\upcite{chen2013computing}，即$Algorithm$\ref{UP}。
\RestyleAlgo{ruled}\LinesNumbered\input{algorithm/UP.tex}

其中的$Lit(P) = Atoms(P) \cup \{ \neg a~|~a \in Atoms(P)\}$\upcite{ji2010phd}，$unit\_clause(\Gamma)$为子句集$\Gamma$中的单元子句集合，$assign(A,\Gamma)=\{ c~|~for~same~c' \in \Gamma,~c' \cap A = \emptyset,~and~c = c' \backslash \overline{A} \}$\upcite{chen2013computing}。

定义以下算子以计算$GUS(P,L)$：
\begin{definition}\label{phi_l} \upcite{chen2013computing}
	给逻辑程序$P$，定文字集$L$和原子集$X$，定义算子$\varPhi_L(X)$：
	\begin{equation}\label{Phi_L_X}
		\begin{array}{rcl}
			\varPhi_L(X)~=~\{ a~|~\exists r \in P,~a \in head(r)~and~a \notin \{ p~|~\neg p \in L \}, \\
			body(r) \cap (\{ p~|~\neg p \in L \} \cup \{ \neg p~|~p \in L \}) = \emptyset, \\
			body^+(r) \subseteq (X \backslash \{ p~|~\neg p \in L \}),~head(r) \cap L = \emptyset \}
		\end{array}
	\end{equation}
\end{definition}

则有逻辑程序$P$的最大无理集为\upcite{chen2013computing}：
\begin{equation}\label{d_gus}
	GUS(P,L) = Atoms(P) \backslash lfp(\varPhi_L(X) \cup \{ p~|~p \in L \})
\end{equation}

其中$lfp(\phi)$为计算极小不动点，故这里的$X$从$\emptyset$开始计算，直到$lfp(\phi) = \phi$得到极小不动点。

记逻辑程序$P$的程序结论为$conq(P)$，其计算公式为\upcite{chen2013computing}：
\begin{equation} \label{conq_P}
	conq(P)~=~lfp(UP(L,P) \cup \neg GUS(P,L)) 
\end{equation}

其中$UP(L,P)~=~L \cup UP(assign(L,P))$。



在介绍了ASP逻辑程序的回答集后，接下来将说明ASP逻辑程序中的一个重要性质，即ASP逻辑程序中的环以及对应的环公式。



\subsection{回答集编程的主要性质：环与环公式}

Lin和Zhao则在2002年时给出了正规逻辑程序中的环，同时使用命题公式基于环定义了其环公式\upcite{lin2004assat}。Lee和Lifschitz在2003年时给出了析取逻辑程序中的环的概念\upcite{lee2003loop}。

在给出具体的环及环公式定义前，需要先给出一个逻辑程序的正依赖图（$Positive~Dependence~Graph$）及强连通分量的定义。
\begin{definition}[正依赖图（$Positive~Dependency~Graph$）\upcite{lin2004assat}]
	已知一个逻辑程序$P$，以$P$中的原子作为顶点，规则作为构成边的依据，可以构造出一个有向连通图，称其为逻辑程序$P$的正依赖图，记为$G_P$。其中，当存在$P$中的一个规则形如$p \in head(r)$且$q \in body^+(r)$，则正依赖图中存在一条从原子$p$指向原子$q$的有向边。
\end{definition}

\begin{definition}[强连通分量（$Strongly~Conntected~Component, SCC$）\upcite{aspvall1979linear}]
	一个有向图$G$中的一个强联通分量$SCC$是满足对于任意两个节点$s_1$，$s_2~\in~SCC$均存在一条路径从$s_1$到达$s_2$，且该路径中的所有节点均属于$SCC$。
\end{definition}

\begin{example}
	给定逻辑程序$P$如下：
	
	\begin{eqnarray}
		a~\leftarrow~not~d.	\\
		d~\leftarrow~not~c.	\\
		a~\leftarrow~c,~d.	\\
		c~\leftarrow~a.
	\end{eqnarray}
	
	根据定义，关于逻辑程序P的正依赖图如下：
	\begin{figure}[htb]
		\center
		\includegraphics[width=300pt]{img/dpg.png}\\
		\caption{$P$的正依赖图}\label{fig:trp}
	\end{figure}
\end{example}

有了正依赖图后，我们引入基于正依赖图拓扑结构所定义的环。


\begin{definition}[环（$Loop$）\upcite{lin2004assat}]\label{loop}
	给定一个逻辑程序$P$，对于$Atoms(P)$的任意非空子集$L$，如果对于$L$中的任意两个原子$p$、$q$，$G_P$中都有至少一条长度大于0的路径使得$p$可达$q$，则称$L$是$P$的一个环（$Loop$）。此外，任意单原子集合也属于一个环。
\end{definition}

逻辑程序的环实质上就是其对应的正依赖图中的强连通分量。逻辑程序的环还有一个重要性质用于定义环公式，那就是环的外部支持规则（$External~Support~Rules$）。环的外部支持是一个规则集合。环$L$在逻辑程序$P$中的外部支持规则用集合符号定义如下：

\begin{equation}
	R^-(L,P)~=~\{r \in P~|~head(r) \cap L \neq \emptyset,~body^+(r) \cap L = \emptyset  \}
\end{equation}

还可以更进一步地定义环$L$在逻辑程序$P$中基于原子集$X$的外部支持规则，用集合符号定义如下：

\begin{equation}
	R^-(L,P,X)~=~\{r \in R^-(L,P)~|~X \models body(r) \land \bigwedge_{q \in head(r) \\ L} \neg q \}
\end{equation}

\begin{definition}[环公式（$Loop~Formula$）\upcite{lin2004assat}]\label{loop_formula}
	给定逻辑程序$P$，对于其中的任意一个环$L$，$R^- (L,P)$为$L$在$P$中的外部支持规则，$L$对应的环公式记为$LF(L,P)$，定义如下：
	
	\begin{equation}
		\bigwedge_{p \in L} p \supset \bigvee_{r \in R^-(L,P)} (body(r) \land \bigwedge_{q \in head(r) \\ L} \neg q)
	\end{equation}
\end{definition}

%%% 环公式被满足的定义
对于一个原子集$S$和$L$，若有$L \subseteq S$推出存在规则$r \in R^-(L,P)$满足$S \models body(r)$及$(head(r) \backslash L) \cap S = \emptyset$，则称$S$满足$L$，记为$S \models L$。


\begin{proposition}\upcite{lee2003loop}
	给定一个逻辑程序$P$和一个原子集合$S$。如果$S$满足$P$，则以下说法是等价的：
	
	\begin{itemize}
		\item $S$是$P$的一个回答集；
		\item $S$满足$P$中所有环$L$的环公式$LF(L,P)$；
		\item $S$满足$Atoms(P)$所有非空子集$E$的环公式$LF(E,P)$。
	\end{itemize}
\end{proposition}


研究ASP逻辑程序中的环，是很有意义的。在ASP逻辑程序中，使用SAT求解器得到的模型不完全是ASP逻辑程序的回答集。其根本原因就在于环的存在。如果ASP逻辑程序中存在环，即存在环内所有原子相互推导的行为，即环内的原子相互推导对方为真，这样就会产生大量模型。然而，从回答集语义出发，这其中如果没有事实或者失败即否定的支持，推导不成立，所以这些模型不是回答集。而环公式就是提取正体部原子全在环外的规则以支持环内原子的成立，这也是外部支持规则的名字由来。基于这样的事实，Lin和Zhao提出了使用环公式求解ASP逻辑程序回答集的方法，并实现了ASP求解器――ASSAT。

在介绍Lin和Zhao的结论之前，先引入逻辑程序的完备（$Completion$）。逻辑程序的完备的具体定义如下：
\begin{definition}[完备（$Completion$）\upcite{lin2004assat}]\label{completion}
	给定一个逻辑程序$P$，其完备（$Completion$），记为$Comp(P)$。$Comp(P)$是以下规则的集合：
	
	\begin{itemize}
		\item 对于任意$p \in Atoms(P)$，$P$中所有以$p$作为头部的规则形如$p \leftarrow G_k$，则$p \equiv G_1 \lor G_2 \lor ... \lor G_n$为$Comp(P)$中的元素，特别地，如果一个原子$p$没有作为头部出现过，那么把$\neg p$加入到$Comp(P)$中；
		\item 对于$P$中的所有限制，形如$\leftarrow~G_k$，把$\neg~G_k$加入到$Comp(P)$中。
	\end{itemize}
\end{definition}

其中第一部分为克拉克完备（$Clark~Completion$）\upcite{clark1978negation}。一个逻辑程序的完备具体计算如下例子所示：
\begin{example}\upcite{lin2004assat}
	有以下逻辑程序$P$：
	\begin{eqnarray}
		a~\leftarrow~b,~c,~not~d.	\\
		a~\leftarrow~b,~not~c,~not~d.	\\
		\leftarrow~b,~c,~not~d.
	\end{eqnarray}
	
	则其完备$Comp(P)$为：	
	\begin{equation}
		\{ a \equiv (b \land c \land \neg d) \lor (b \land \neg c \land \neg d),~\neg b,~\neg c,~\neg d,~\neg (b \land c \land \neg d) \}
	\end{equation}
\end{example}


在有了逻辑程序完备的概念后，我们引入一个新的回答集求解方法。


\begin{theorem}\upcite{lin2004assat}\label{Lin_Zhao_loop_theorem}
	给定逻辑程序$P$，记$Comp(P)$为其完备，$LF$表示$P$中所有环的环公式集合。一个原子集$S$是逻辑程序$P$的回答集，当且仅当它是$Comp(P) \cup LF$的一个模型。
\end{theorem}


Lin和Zhao所提出的环及环公式在后续至今的时间被不断使用。Gebser在2010年时提出了基本环（$Elementary~Loop$）\upcite{gebser2011elementary}，其是一系列可以代表其他环的环，Gebser还将基本环应用到clasp求解器中。2014年，Ji和Wan等在Gebser的基本环的基础上更进一步地在正规逻辑程序中提出了更具有代表性的特征环（$Proper~Loop$）\upcite{ji2014elementary}，并在不久后将特征环拓展到析取逻辑程序\upcite{ji2015elementary}。




\section{分割集与程序分割}


Lifschitz和Turner在1994年时便提出了分割集（$Splitting~Set$）的概念。其本意是为了把逻辑程序划分成若干个较小规模的程序，然后通过这些小规模的程序的回答集去求解原程序的回答集。由于逻辑程序的规模对求解效率有很大的影响，通过把逻辑程序的规模降低，把指数性的关系降为加性关系，将大大有助于提高逻辑程序的求解效率。但ASP逻辑程序是非单调的，要达到分割程序后得到的回答集是原程序的回答集，需要满足一定的条件\upcite{ji2010phd}。

Lifschitz和Turner在给出分割集的概念后，也基于分割集提出了相应的程序分割（$Program~Splitting$）方法。程序分割方法具体就是根据定义找出分割集，通过分割集把原程序分割为底部（$bottom$）和顶部（$top$）两部分，并且证明原程序的回答集可以通过$bottom$和$top$两部分的回答集所求得。


\begin{definition}[分割集（$Splitting~Set$）\upcite{lifschitz1994splitting}]\label{splitting_set}
	给定一个逻辑程序$P$，其分割集（$Splitting~Set$）是一个原子集，标记为$U$，分割集$U$需要满足：对于任意的规则$r \in P$，$head(r) \cap U \neq \emptyset$蕴涵$Atoms(r)\subseteq U$。
\end{definition}


直观地，分割集中原子对应为逻辑程序$P$的正依赖图中出度为零的顶点\cite{ji2010phd}。基于分割集，可以把原程序划分成$bottom$和$top$两部分，具体定义如下：


\begin{definition}[底部和顶部（$bottom~and~top$）\upcite{lifschitz1994splitting}]\label{bottom_top}
	给定一个逻辑程序$P$，及其分割集$U$，标记$P$的底部为$b_U(P)$，顶部为$t_U(P)$，使用集合符号定义为：
	
	\begin{eqnarray}
		b_U(P) = \{ r \in P~|~head(r) \cap U \neq \emptyset \}	\\
		t_U(P) = P~\backslash~b_U(P)
	\end{eqnarray}
	
	其中“$\backslash$”为集合减。
\end{definition}

明显地，逻辑程序的$bottom$是把分割集$U$相关的规则都抽取出来，而$top$则是头部与分割集$U$无关的规则集合。$\emptyset$和$Atoms(P)$是任意一个逻辑程序P的分割集\upcite{ji2010phd}。

为了求解原程序的回答集，需要引入化简操作，Lifschitz和Turner定义了操作$e_U(P,X)$来联合$bottom$的回答集和$top$求出另一部分的回答集。


\begin{definition}\label{e_U_P_X}
	给定逻辑程序$P$，$X$和$U$为原子集合，定义操作$e_U(P,X)$如下：
	
	\begin{itemize}
		\item 删除符合以下条件的规则$r$：$head(r) \cap X \neq \emptyset$且$body^+(r) \cap U \nsubseteq X$，或者$(body^-(r) \cap U) \cap X \neq \emptyset$；
		\item 在剩下的规则的体部中把所有形如$a$或$not~a$，其中$a \in U$的文字删掉。
	\end{itemize}
\end{definition}


\begin{definition}\label{asp_solution}
	给定逻辑程序$P$，及其分割集$U$，$P$关于$U$的一个方案（$Solution$）是一个原子集组合$\langle X,Y \rangle$，具体如下：
	\begin{itemize}
		\item $X$是$b_U(P)$的回答集；
		\item $Y$是$e_U(P \backslash b_U(P), X)$的回答集。
	\end{itemize}
\end{definition}



\begin{example}
	考虑逻辑程序$P$：
	\begin{eqnarray}
		a~\leftarrow~not~d.	\\
		d~\leftarrow~not~c.	\\
		a~\leftarrow~c,~d.	\\
		c~\leftarrow.
	\end{eqnarray}
	
	根据定义可知$U=\{c,d\}$是$P$的一个分割集，并且可以计算得到$b_U(P)=\{d \leftarrow not~c.~c \leftarrow.\}$，而$P \backslash b_U(P) = \{a \leftarrow not~d.~a \leftarrow c,~d.\}$，$\{c\}$是$b_U(P)$的回答集，故令$X=\{c\}$，有$e_U(P \backslash b_U(P),X)=\{a \leftarrow.\}$，其回答集为$\{a\}$。$\langle \{c\},\{a\} \rangle$则是$P$关于$U$的一个方案，于本例也是唯一的方案。
\end{example}


关于原程序的回答集，可以通过上述定义的逻辑程序关于分割集的方案得到，Lifschitz和Turner给出了分割集理论就是证明了如果从方案得到回答集。


\begin{theorem}[分割集理论（$Splitting~Theorem$）\upcite{lifschitz1994splitting}]
	已知逻辑程序$P$和其分割集$U$，则一个原子集$S$是逻辑程序$P$的回答集，当且仅当$S = X \cup Y$，其中$\langle X,Y \rangle$是$P$关于$U$的一个方案。
\end{theorem}


关于回答集编程的基础知识和分割集理论的主要知识介绍到此。接下来将进入本文的主要内容，介绍新的分割集和新的程序分割方法，以及通过具体的应用场景来体现分割集的意义。


