\chapter{新分割集与程序分割}

本章基于对Lifschitz和Turner提出的分割集和程序分割理论的分析，提出了新的分割集和程序分割方法。实际上是提出了一个可以对任意原子集作为分割集都有效的程序分割方法。本章将分别给出正规逻辑程序和析取逻辑程序的新程序分割方法，然后提出一个强程序分割方法。最后以正规逻辑程序的程序分割方法为例，对新的程序分割方法的计算复杂性进行分析，并指出主要性能瓶颈所在及改进思路。


\section{新分割集}

在给出新分割集之前，本文将对Lifschitz和Turner提出的分割集理论进行分析，然后基于他们对分割集的定义提出一个计算分割集的算法，并对ASP竞赛中的程序进行计算，对计算结果进行分析，随后给出本文定义的新分割集。


\subsection{原有分割集和程序分割的分析证明}

Lifschitz和Turner给出的分割集定义是：一个原子集$U$称为一个逻辑程序$P$的分割集，当且仅当对$P$中的所有规则$r$都有$head(r) \cap U \neq \emptyset$蕴涵$Atoms(r) \subseteq U$。这个分割集定义的直观含义就是一个分割集若包含规则头部的原子，则也可以包含该规则的所有原子。这样的性质保证了分割集$U$可以把原程序从结构上划分成两部分，进而保证了原程序的回答集可以从分割后的两部分的回答集求解得到。Lifschitz和Turner在1994年的原文中只给出了程序分割方法的定义，即根据定义(\ref{asp_solution})分别求出底部$b_U(P)$和化简后的顶部$e_U(t_U(P),X)$的回答集$X$和$Y$，根据方案$\langle X,Y \langle$得到原程序的回答集。本文在这里补充给出这种分割方法的可行性证明。关于Lifschitz和Turner的程序分割方法可行性的证明如下。



\begin{proof}
首先证明分割集可以把逻辑程序划分为回答集互斥的两部分，并且底部的回答集是原逻辑程序回答集子集。

根据定义\ref{splitting_set}，分割集$U$满足对于逻辑程序$P$中任意的规则$r$都有，$head(r) \cap U \neq \emptyset$蕴涵$Atoms(r) \subseteq U$。而根据定义\ref{bottom_top}有：	
\begin{eqnarray}
	b_U(P) = \{ r \in P~|~head(r) \cap U \neq \emptyset \}	\\
	t_U(P) = P~\backslash~b_U(P)
\end{eqnarray}

根据分割集$U$的特性，可以知道：$Atoms(b_U(P)) \subseteq U$，并定义：
\begin{eqnarray}
	head(t_U(P))~=~\bigcup_{r \in t_U(P)} head(r)	\\
	body(t_U(P))~=~\bigcup_{r \in t_U(P)} body(r)
\end{eqnarray}

另，记一个逻辑程序$P$的回答集为$\Gamma (P)$，而回答集必是一个逻辑程序的头部原子的子集，即$\Gamma (P) \subseteq head(P)$。根据$t_U(P)$的定义可以知道：	
\begin{eqnarray}
	head(t_U(P)) \subseteq Atoms(P) \backslash U \\
	\Gamma (b_U(P)) \subseteq U
\end{eqnarray}
由于$head(t_U(P)) \cap U = \emptyset$，所以$\Gamma (t_U(P)) \cap U = \emptyset$，故有$\Gamma (b_U(P)) \cap \Gamma (t_U(P)) = \emptyset$，这样保证了$b_U(P)$和$t_U(P)$的回答集是互斥的。此外，我们已知：	
\begin{eqnarray}
	Atoms(b_U(P)) \subseteq U \\
	head(t_U(P)) \subseteq Atoms(P) \backslash U \\
	head(b_U(P)) \cap head(t_U(P)) = \emptyset
\end{eqnarray}

这些关系表明$b_U(P)$于原逻辑程序而言，是一个独立的模块，其回答集只能从$b_U(P)$这部分推出，因为$head(b_U(P))$中的原子不会出现在$head(t_U(P))$中，即$\Gamma (b_U(P))$中的元素不需要依赖$t_U(P)$中的规则，一旦$head(b_U(P))$中的某个元素被推出为真，那么放在整个程序它都将是真的，即它必为原程序回答集的元素，即$\Gamma (b_U(P))$中的元素必将出现在原程序的某个回答集中。

然而，并不是直接计算$b_U(P)$和$t_U(P)$的回答集就可以得到最终的回答集。因为$body(t_U(P))$中可能会包含有$U$中的原子，而如果这些原子是在$\Gamma (b_U(P))$中的话，我们是可以知道其真值的，因为$\Gamma (b_U(P))$必是原程序回答集的一部分。那么需要定义一个操作来删除这些可以肯定真值的原子。这个操作就是定义\ref{e_U_P_X}中的$e_U(P,X)$。

接着证明$e_U(P,X)$的有效性。

令$X = \Gamma (b_U(P))$。对于$X$中的原子，其在$t_U(P)$中的形式只有正文字和负文字，即$x$或$not~x$，$x \in X$。

在$e_U(P,X)$的定义中，它只保留满足以下条件的规则$r$：$body^+(r) \cap U \subseteq X$，及$(body^-(r) \cap U) \cap X = \emptyset$。并在保留下来的规则中删去所有形如$a$或$not~a$，其中$a \in U$的文字。	
\begin{enumerate}
	\item 对于满足$body^+(r) \cap U \subseteq X$的规则$r$，后续的化简操作是$body^+(r) \backslash U$，而$X \subseteq U$，且$body^+(r) \cap U \subseteq X$，所以实质的意义就是$body^+(r) \backslash X$。对于$x \in body^+(r) \cap X$，因为$x \in X$，$X = \Gamma (b_U(P))$，并且$X$必为原程序回答集的一部分，所以$x$也为原逻辑程序中某个回答集的元素，所以可以确定$x$为真，且体部为合取关系，根据$head(t_U(P)) \subseteq Atoms(P) \backslash U$，即$x$在$t_U(P)$中不会在出现在规则的头部，即在$t_U(P)$中不可能推出$x$为真，但从$X$可以确定其为真，故需要删去$x$。所以保留满足$body^+(r) \cap U \subseteq U$的规则$r$，并执行$body^+(r) \backslash U$操作。
	\item 对于满足$(body^-(r) \cap U) \cap X= \emptyset$的规则$r$，后续的化简操作是$body^-(r) \backslash U$。反向考虑，如果$(body^-(r) \cap U) \cap X \neq \emptyset$，即规则$r$的体部中包含$not~a$，$a \in X$。而从上面的说明可以知道$a \in X$，则可以判定$a$为真，即$not~a$为假（因为“推不出$a$为真”为假）。而体部为合取关系，一旦确定体部中有为假的元素，则体部为假，该规则无法推出头部为真，所以可以删去该规则，故只考虑满足$(body^-(r) \cap U) \cap X = \emptyset$的规则。此外，对于满足这个条件的规则，其$body^-(r) \cap X = \emptyset$，而对于$body^-(r)$可能存在$U \backslash X$中的元素，$U \backslash X$中的元素直接含义就是原程序回答集中推不出为真的原子，所以若$b \in U \backslash X$，则$not~b$为真。跟1中一样，体部为真的元素应该直接删去。所以保留满足$(body^-(r) \cap U) \cap X = \emptyset$的规则$r$，并执行$body^-(r) \backslash U$的操作。
\end{enumerate}	

根据上面的证明可以知道，$X$作为原程序回答集的一部分，$e_U(t_U(P),X)$利用$X$中元素的真值化简出一个计算原程序剩下回答集部分的逻辑程序。记$Y = \Gamma (e_U(t_U(P),X))$。
	
$b_U(P)$中只包含$U$中的原子，它自身是一个命题闭包，所以求解得到的回答集$X$必是原程序回答集的部分。而$e_U(t_U(P),X)$得到一个跟$U$无关的程序，同时确保了$X$中的元素为真，所以这部分求解得到的回答集$Y$就是原程序回答集剩下的部分。且有	
\begin{eqnarray}
	X \subseteq Atoms(P) \cap U	\\
	Y \subseteq Atoms(P) \backslash U
\end{eqnarray}	
	
所以$X \cap Y = \emptyset$，故$X \cup Y$是确保一致的，并且为原程序的回答集。\quad
\end{proof}


上述证明过程说明了Lifschitz和Turner提出的程序分割方法的有效性。由于$U$是一个命题闭包，它能有效地把一个逻辑程序的规则根据自己的闭包性在结构上一分为二。



\subsection{提出新的分割集}\label{section_3_1_2}

Lifschitz和Turner给出的分割集的定义实际上是一个验证型定义。他们定义一个原子集$U$是逻辑程序$P$的分割集，当且仅当$P$中的每个规则$r$满足$head(r) \cap U \neq \emptyset$蕴涵$Atoms(r) \subseteq U$。这个定义从直观上来说就是如果一个原子集合是一个逻辑程序的分割集，那么它满足逻辑程序中凡是头部与其有交集的规则，都会有该规则的所有原子都在该原子集合内。本文根据Lifschitz和Turner对分割集的定义给出了一个计算逻辑程序的分割集的算法，为$Alogrithm$\ref{LifschitzU}。

% 插入算法
\RestyleAlgo{ruled}\LinesNumbered\input{algorithm/LifschitzU.tex}

明显地，$\emptyset$和$Atoms(P)$都是任何逻辑程序的分割集。而本文把上述算法应用在ASP竞赛的逻辑程序中，得到的结果为大部分逻辑程序的分割集都是$Atoms(P)$。这样的事实说明，Lifschitz和Turner所定义的分割集从理论上是美好的，它是一个从原程序中抽取出来的命题闭包，直观来看，这样的一个命题闭包就是逻辑程序正依赖图中没有出边的子图，这样的子图不受其他命题作为外部支持，所以在求解回答集上也自封闭，具有良好的独立性。然而从ASP竞赛的逻辑程序的计算结果可以知道，实际中的程序并非都具有如此性能优良的子图。为了能让分割集的思想能应用到一般的情景下，本文对其Lifschitz和Turner的分割集理论进行了扩展。事实上，本文并没有定义一个新的分割集，而是定义了一个新的程序分割方法，并确保这个新的程序分割方法能对任意原子集构成的分割集都有效。即新的分割集被扩展为任意原子集，摆脱了原有分割集对逻辑程序的拓扑结构的强依赖性。




\section{新程序分割方法}

本节中将分别给出正规逻辑程序和析取逻辑程序的程序分割方法，这两者间的主要不同在于对顶部（$top$）的定义，这也由正规逻辑程序和析取逻辑程序的回答集语义所决定。在介绍正规逻辑程序的程序分割方法过程中，本节会在定义操作符的同时给出其直观上的含义，并证明新的程序分割方法对任意原子集构成的分割集的有效性。然后，本节会提出一个强程序分割方法，该方法是为了补充把程序分割方法在分配律下的有效性。

\subsection{正规逻辑程序分割方法}

Lifschitz和Turner的程序分割方法是基于分割集进行的，而根据\ref{section_3_1_2}的结果表明，对于大部分逻辑程序，分割集往往就是$Atoms(P)$。这样的分割集无法分割逻辑程序，所以本文提出了新的程序分割方法，以支持分割集可以为任意原子集。
首先，本文继续使用定义\ref{bottom_top}中的$b_U(P)$和定义\ref{e_U_P_X}中的操作$e_U(P,X)$，依旧记分割集为U。而此时分割集$U$并不存在命题封闭性，即：
\begin{equation}
	Atoms(b_U(P)) \subseteq U
\end{equation}

不一定成立。可以更为直接地说，大部分情况下都不再成立。为了保证新程序分割方法的普遍适用性，我们考虑：
\begin{equation}
Atoms(b_U(P)) \nsubseteq U
\end{equation}

事实上此时有效的方法对$Atoms(b_U(P)) \subseteq U$情况下一样有效，因为附加操作都是为了保证最坏情况的。

在原来的分割集下，$b_U(P)$内保证了命题封闭性，即有：
\begin{equation}
	Atoms(b_U(P)) \cap head(P \backslash b_U(P)) = \emptyset
\end{equation}

即如果$Atoms(b_U(P))$中的原子属于回答集，那么它只会在$b_U(P)$中被推出。而对于$U$为任意原子集的情况下，有：
\begin{equation}
	Atoms(b_U(P)) \backslash U \neq \emptyset
\end{equation}

所以需要考虑$Atoms(b_U(P)) \backslash U$这部分原子的真值可能性问题。而事实上，这部分原子的真值仅靠$b_U(P)$是无法确定的，因为它们可能是$P \backslash b_U(P)$中某个规则的头部，即可能会在$P \backslash b_U(P)$部分被推出。所以最直接也是最有效的方法就是在$\Gamma (b_U(P))$中加入这些不确定原子真值的全排列。然而，这些原子的真值也并非可以任意猜测，需要配合$b_U(P)$中的逻辑关系，所以本文定义了规则集合，来确保这些原子的真值在合理推导下被遍历。
\begin{definition}
	规则集合$EC_U(P)$为$Atoms(b_U(P)) \backslash U$中的原子的真值可能性提供补充规则，有：
	\begin{equation}
		EC_U(P)~=~\{ p~\leftarrow~not~p'.~p'~\leftarrow~not~p.~|~p \in Atoms(b_U(P)) \backslash U \}
	\end{equation}
\end{definition}

$EC_U(P)$为$Atoms(b_U(P)) \backslash U$中的原子引入一组规则：
\begin{equation}
	p~\leftarrow~not~p'.~p'~\leftarrow~not~p.
\end{equation}

其中的$p'$其实代表的就是$\neg p$，上面一组规则在ASP逻辑程序中的含义是$p \lor not~p.$，换句话说即，如果一个ASP逻辑程序只有这两个规则，那么它的回答集就是$\{ \{p\},\{p'\} \}$，实际就是$\neg p$或$p$。接着，通过一个简单的例子来展现$EC_U(P)$的效果。
\begin{example}
	给定逻辑程序$P_1$：
	\begin{eqnarray}
		a~\leftarrow~not~d.	\\
		d~\leftarrow~not~c.	\\
		c~\leftarrow~a.	\\
		a~\leftarrow~c,~d.
	\end{eqnarray}
	令分割集$U=\{a\}$，则有：
	\begin{equation}
		b_U(P_1)~=~\{ a~\leftarrow~not~d.~a~\leftarrow~c,~d. \}
	\end{equation}
	使用$gringo$和$clasp$求解得到$\Gamma (b_U(P_1)) = \{ \{a\}  \}$。而$Atoms(b_U(P_1 )) \backslash U = \{c,d\}$，所以根据定义有：
	\begin{equation}
		EC_U(P_1)~=~\{ d~\leftarrow~not~d'.~d'~\leftarrow~not~d.~c~\leftarrow~not~c'.~c'~\leftarrow~not~c. \}
	\end{equation}
	使用$gringo$和$clasp$求解$b_U(P_1) \cup EC_U(P_1)$，得到：
	\begin{equation}
		\Gamma (b_U(P_1) \cup EC_U(P_1)) = \{ \{ a,c,d \}, \{ a,c,d' \}, \{ a,c',d' \}, \{ c',d \} \}
	\end{equation}
	其中的$c'$和$d'$实质代表$\neg c$和$\neg d$。
\end{example}

因为$head(b_U(P)) \subseteq U$，而且$\Gamma (b_U(P)) \subseteq head(b_U(P))$，所以有$\Gamma (b_U(P)) \subseteq U$。$Atoms(b_U(P)) \backslash U$部分的原子真值则无法由$b_U(P)$确定，因为它们有可能被$P \backslash b_U(P)$中的规则推出。加入$EC_U(P)$使得这些原子的真值的有效可能性被加入到$b_U(P)$的回答集中。当然，这里也不是随意的遍历插入。如$\Gamma (b_U(P) \cup EC_U(P))$中只有$\{ c',d \}$而没有$\{a,c',d\}$，这是因为在$\{c',d \}$为真的情况下，原程序无法推出$a$为真。这就是本文定义$EC_U(P)$而没有直接往$b_U(P)$的回答集中遍历插入剩下原子的可能真值组合的原因。

此外，由于现在$Atoms(b_U(P)) \backslash U \neq \emptyset $且在引入$EC_U(P)$后，新的$bottom$（底部）为$b_U(P) \cup EC_U(P)$，记$bottom$的回答集$X=\Gamma (b_U(P) \cup EC_U(P))$，那么这时就有$X \backslash U \neq \emptyset$。

在$Atoms(b_U(P)) \backslash U \neq \emptyset $ 且$X \backslash U \neq \emptyset$的情况下，定义\ref{e_U_P_X}中的操作$e_U(P,X)$只会去掉有形如$a$或$not a$，其中$a \in U$的文字，即只对$U$中的原子进行操作。而实际上，需要保证$U$以外但在$X$中的原子的真值。所以本文为$top$（顶部）定义一个新的规则集合$ECC_U(P,X)$，以保证$X \backslash U$的原子的真值确定性。
\begin{definition}
	规则集合$ECC_U(P,X)$为$P \backslash b_U(P)$提供$X \backslash U$中原子的真值确定性，具体有：
	% 公式换行，手动地使用 \begin{array}
	\begin{equation}
		\begin{array}{rcl}
			ECC_U(P) = \{ \leftarrow~not~p.~|~p \in Atoms(b_U(P)) \backslash U~and~p \in X \} \\
			\cup \{ \leftarrow~p.~|~p \in Atoms(b_U(P)) \backslash U~and~p \notin X \}
		\end{array}
	\end{equation}
\end{definition}

对于$ECC_U(P,X)$直观上的功能就是保证在$P \backslash b_U(P)$中每个原子$p$，若$p \in X$，则要保证$p$为真，即往逻辑程序中加入$\leftarrow~not~p.$；若$p \notin X$，则保证$p$为假，即往逻辑程序中加入$\leftarrow~p.$。基于这样的分析，本文可以得到以下命题。
\begin{proposition}\label{satisfy_proposition}
	已知$P$是一个正规逻辑程序，$U$是一个原子集。那么一个原子集$S \subseteq Atoms(P)$能满足$P$，当且仅当$S = (X \cup Y) \cap Atoms(P)$，其中的$X$和$Y$分别为：
	\begin{itemize}
		\item $X \models b_U(P) \cup EC_U(P)$
		\item $Y \models e_U(P \backslash b_U(P),X) \cup ECC_U(P,X)$
	\end{itemize}
\end{proposition}

显然，依据定义$EC_U(P)$和$ECC_U(P,X)$过程中的分析便可以清楚地知道命题\ref{satisfy_proposition}的正确性。接下来，看一个验证命题\ref{satisfy_proposition}的例子。
\begin{example}\label{example_3_2}
	继续使用逻辑程序$P_1$，并令分割集$U=\{a\}$，那么可以计算得到：
	\begin{equation}
		b_U(P_1)~=~\{ a~\leftarrow~not~d.~a~\leftarrow~c,~d. \}
	\end{equation}
	及：
	\begin{equation}
		EC_U(P_1)~=~\{ d~\leftarrow~not~d'.~d'~\leftarrow~not~d.~c~\leftarrow~not~c'.~c'~\leftarrow~not~c. \}
	\end{equation}
	且求解得到：
	\begin{equation}
		\Gamma (b_U(P_1) \cup EC_U(P_1)) = \{ \{ a,c,d \}, \{ a,c,d' \}, \{ a,c',d' \}, \{ c',d \} \}
	\end{equation}
	令$X=\{a,c,d'\}$，显然，$X \models b_U(P_1 ) \cup EC_U(P_1)$。另，根据定义，可以计算得：
	\begin{equation}
		\begin{array}{rcl}
			e_U(P_1 \backslash b_U(P_1), X) = \{ d~\leftarrow~not~c.~c~\leftarrow. \}	\\
			ECC_U(P_1, X) = \{ \leftarrow~not~c.~\leftarrow~d. \}
		\end{array}
	\end{equation}
	并求解得到：
	\begin{equation}
		\Gamma (e_U(P_1 \backslash b_U(P_1), X)) = \{ \{ c \} \}
	\end{equation}
	令$Y=\{c\}$，显然，$Y \models e_U(P_1 \backslash b_U(P_1 ),X) \cup  ECC_U(P_1,X)$。$X \cup Y = \{a,c,d'\}$，明显也有$X \cup Y \models P_1$。
\end{example}

在引入了$EC_U(P)$和$ECC_U(P,X)$后，依据命题\ref{satisfy_proposition}，可以知道原程序的模型可以通过$bottom$和$top$两部分的模型计算得到。然而，直接使用$P \backslash b_U(P)$作为$top$并不能求解出原程序剩下的回答集。这是因为分割集$U$把逻辑程序$P$划分为$bottom$和$top$两部分的同时也会可能破坏了$P$中的某些环$L$。接下来，本文将使用逻辑程序中的环与环公式的理论，来定义可以用于求解原程序的$top$部分。首先，这里定义两个结构性的规则集合。
\begin{definition}\label{in_out}
	对一个逻辑程序$P$基于一个原子集$U$，定义以下两个规则集合：
	\begin{eqnarray}
		in_U(P) = \{ r \in P~|~head(r) \cap U \neg \emptyset~and~(body^+(r) \cup head(r)) \subseteq U \}	\\
		out_U(P) = \{ head(r) \subseteq U~and~(body^+(r) \cup head(r)) \cap U \neq \emptyset \}
	\end{eqnarray}
\end{definition}

$in_U(P)$和$out_U(P)$是与逻辑程序正依赖图结构性相关的规则集合。在正规逻辑程序中直观的含义是，$in_U(P)$代表了头部属于分割集$U$，而体部正原子存在与$U$中原子不同的原子；$out_U(P)$代表了头部不属于分割集$U$，而体部正原子存在与$U$中原子相同的原子。根据两者的定义，显然可以得到：
\begin{eqnarray}
	in_U(P) \subseteq b_U(P)	\\
	out_U(P) \subseteq P \backslash b_U(P)
\end{eqnarray}

在有了$in_U(P)$和$out_U(P)$的概念后，基于环理论给出以下定义。
\begin{definition}[半环]\label{semi_loop}
	一个非空原子集$E$称为逻辑程序$P$基于原子集$U$的半环（$smei-loop$），当且仅当在$P$中存在一个环$L$使得$E = L \cap U$且$E \subset L$。
\end{definition}
\begin{definition}\label{SLUP}
	已知正规逻辑程序$P$和原子集$X$、$U$，且$E$为$P$基于$U$的半环，定义一个半环集合如下：
	\begin{equation}
		SL_U(P,X) = \{ E~|~E \subseteq X~and~R^-(E,P,X) \subseteq in_U(P) \}
	\end{equation}
\end{definition}

根据$semi-loop$和$SL_U(P,X)$的定义，可以得到以下引理。
\begin{lemma}\label{lem_slupx}
	一个半环$E$属于$SL_U(P,X)$，则$P$中存在一个环$L$满足$E \subset L$且$X \nvDash LF(L,P)$。	
\end{lemma}

\begin{proof}
	使用反证法。
	
	分割集$U$在把逻辑程序$P$划分为两部分的同时可能会破坏$P$中的某些环$L$。这些被破坏的环可以分为两类：
	\begin{itemize}
		\item 该环已经被$bottom$部分的回答集$X$所满足；
		\item 该环不能被$bottom$部分的回答集$X$所满足，需要$top$部分的回答集与$X$的并集去满足。
	\end{itemize}
	
	对于逻辑程序$P$中一个环$L$，其与分割集$U$的关系可以分为以下的情况：
	
	1） $L \subseteq U$。则对于规则$r \in R^-(L,P)$有$head(r) \cap L \neq \emptyset$，故$head(r) \ cap U \neq \emptyset$，所以$r \in b_U(P)$，因此可以得到：
	\begin{equation}
		R^-(L, P) = R^-(L, b_U(P) \cup EC_U(P))
	\end{equation}
	
	故有：
	\begin{equation}
		LF(L,P) = LF(L, b_U(P) \cup EC_U(P))
	\end{equation}
	
	而$X \in \Gamma (b_U(P) \cup EC_U(P))$，所以有：
	\begin{equation}
		X \models LF(L, b_U(P) \cup EC_U(P))
	\end{equation}
	
	进而有：
	\begin{equation}
	X \models LF(L,P)
	\end{equation}
	
	2） $L \nsubseteq U$且$L \cap U = \emptyset$，即$L \subseteq Atoms(P) \backslash U$。这样的环$L$即与$b_U(P)$，完全在$P \backslash b_U(P)$中。因为$L \cap U = \emptyset$，则$L \nsubseteq X$。根据环公式被一个原子集满足的定义可以知道$L \nsubseteq X$使得前键为假，故定义中的蕴涵式为真，即有$X \models LF(L,P)$。
	
	当环$L$完全在$b_U(P)$中时，或者环$L$完全在$P \backslash b_U(P)$中时，$X$能满足其环公式。实际上这样的环不属于被$U$破坏的环。以下情况的环为被$U$破坏的环。
	
	3） $L \nsubseteq U$且$L \cap U \neq \emptyset$。
	
	当$(L \cap U) \nsubseteq X$时，$L \nsubseteq X$，$X \models LF(L,P)$。
	
	当$(L \cap U) \subseteq X$时，若$L \nsubseteq X$，则也有$X \models LF(L,P)$。这两种即前面说到的环被破坏了，但$X$能满足其环公式的情况。
	
	若$L \subseteq X$时，若$R^-(L \cap U, P, X) \backslash in_U(P) \neq \emptyset$，即存在规则$r \in R^-(L \cap U, P, X) \backslash in_U(P)$，且有$R^-(L \cap U, P, X) \in b_U(P)$。
	
	对于$r \notin in_U(P)$，所以有$body^+(r) \subseteq U$。
	
	对于$r \in R^-(L \cap U, P, X)$，所以有$body^+(r) \cap (L \cap U) \neq \emptyset$，且已有$L \cap U \neq \emptyset$和$body^+(r) \subseteq U$，故$body^+(r) \cap L = \emptyset$。同时，$head(r) \cap (L \cap U) \neq \emptyset$，所以$head(r) \cap L \neq \emptyset$。故可以得到存在一个规则$r \in R^-(L,P)$且$X \models body(r)$，所以有$X \models LF(L,P)$。
	
	故令$E = L \cap U$，$E \subseteq X$，且有$R^-(E,P,X) \in in_U(P)$时，就存在一个环$L$有$X \nvDash LF(L,P)$。\quad
\end{proof}

被分割集$U$破坏的环的环公式可能不能为$bottom$的回答集$X$所满足，所以需要剩下部分的回答集联合$X$一起去满足。定义$SL_U(P,X)$是为了找出$P$中环公式不能被$X$所满足的环。根据这些被破坏的环，引用Lin和Zhao在2004年提出的环理论，本文将定义新的$top$以保证最后得到的回答集能满足这部分环的环公式。
\begin{definition}\label{new_top}
	给定$P$为一个正规逻辑程序，$X$和$U$为原子集，$P$基于$U$通过$X$得到的$top$记为$t_U(P,X)$，其由以下三部分组成：
	\begin{itemize}
		\item $P \backslash (b_U(P) \cup out_U(P)$，
		\item $\{ x_E~\leftarrow~body(r)~|~r \in in_U(P)~and~r \in R^-(E,P,X) \},~for~each~E \in SL_U(P,X)$，
		\item $\{ head(r)~\leftarrow~x_{E_1},x_{E_2},...,x_{E_t},body(r)~|~r \in out_U(P),~for~all~possible~E_i \in SL_U(P,X)(1 \leq i \leq t)~s.t.~body^+(r) \cap E_i \neq \emptyset \}$。
	\end{itemize}
\end{definition}

其中$x_{E_i}$为基于$SL_U(P,X)$中的$smei-loop$引入的新原子，对于这些新原子，最后通过逻辑交$Atoms(P)$即可消去。新的$top$由三部分组成，其中第一部分从$P$中去除了$b_U(P)$和$out_U(P)$，事实上$b_U(P)$和$out_U(P)$不是单纯地被去掉，而是分别在第二和第三部分被重构以与第二部分基于$in_U(P)$的规则构成环。下面给出新的$top$求解得到的回答集$Y$能满足$body(r)$，其中$r \in R^-(L,P)$的证明。
\begin{proof}\label{proof_top}
	新的$top$的第一部分首先去除了$bottom$部分的规则，同时去除$out_U(P)$中的规则，待第三部分重构。新的$top$是为了达到保证$(X \cup Y) \cap Atoms(P)$为$P$的回答集，首先证明$(X \cup Y) \cap Atoms(P)$能满足$P$中的所有环。根据引理\ref{lem_slupx}的证明可以知道$X$满足了大部分情况的环公式，对于$X$所不能满足的环公式的情况是环$L \subseteq X$，但不存在$r \in R^-(L,P)$有$X \models body(r)$。若对这样的环都存在$r \in R^-(L,P)$有$Y \models body(r)$，则可以得到明$(X \cup Y) \cap Atoms(P)$能满足$P$中的所有环公式。
	
	而$Y$是$top$部分的回答集，所以$Y$只可能满足$r \in R^-(L,P) \backslash b_U(P)$中的某些$body(r)$。而无法直接判定$Y$能满足哪些$body(r)$。若能构建关于$L \backslash U$的环，则有$R^-(L,P) \backslash b_U(P) \subseteq R^-(L \backslash U, t_U(P,X))$，而$Y$为$top$的回答集，构造关于$L \backslash U$的环在$top$内，必然存在$r \in R^-(L,P) \backslash b_U(P)$有$Y \models body(r)$。
	
	接着证明$t_U(P)$中的第二和第三部分能够构造出关于$L \backslash U$的环，记$r_1 \in out_U(P)$和$r_2 \in in_U(P)$。
	
	对于第二部分中构造的规则$x_E~\leftarrow~body(r_2)$，其中$r_2 \in in_U(P)$且$r_2 \in R^-(E,P,X)$。由于$r_2 \in in_U(P)$，故$r_2 \in b_U(P)$，而且$r_2 \in R^-(E,P,X)$，故有：
	\begin{equation}\label{head_r_2}
		head(r_2) \cap (L \cap U) \neq \emptyset
	\end{equation}
	\begin{equation}\label{body_r_2}
		body^+(r_2) \cap (L \cap U) = \emptyset
	\end{equation}
	
	因为$L$是$P$中的一个环，其被$U$分割为两部分，满足$head(r) \cap (L \backslash U)$的规则$r$不会出现在$b_U(P)$中，而必须存在满足$body(r_2) \cap (L \backslash U) \neq \emptyset$的规则$r_2$，否则无法构成$L$这个环。同时，对于每个满足$body(r_2) \cap (L \backslash U) \neq \emptyset$的规则$r_2$都会使用$E \in SL_U(P,X)$来构成一个新的规则，这是第二部分构造的规则。此外，这些规则都是从$b_U(P)$中提取出来的，$X \in \Gamma (b_U(P) \cup ECC_U(P)$，故对于$r_2 \in b_U(P)$也必然符合$X \models body(r_2)$，不会与$r_2 \in R^-(E,P,X)$产生矛盾。
	
	对于第三部分中构造的规则$head(r_1)~\leftarrow~x_{E_1},~x_{E_2},...,~x_{E_t},~body(r_1)$，其中$r_1 \in out_U(P)$且有：
	\begin{equation}\label{body_r_1}
		body^+(r_1) \cap (L \cap U) \neq \emptyset
	\end{equation}
	
	而为了保证能构成$L$这个环，在$P \backslash b_U(P)$的规则中，对于$body^+(r_1)$中包含$L \cap U$中元素的规则，必存在一个规则满足：
	\begin{equation}\label{head_r_1}
		head(r_1) \cap (L \backslash U) \neq \emptyset
	\end{equation}
	
	根据式子\ref{head_r_2}和\ref{body_r_1}，以及式子\ref{head_r_1}和\ref{body_r_2}，可以知道$(L \backslash U) \cup \{x_E\}$是一个环。即能在$t_U(P)$中必能为被$U$破坏的环$L$构造出一个环，该环就是$(L \backslash U) \cup \{x_E\}$。此外，$e_U(P,X)$只会删去$U$相关的原子，$ECC_U(P,X)$只有限制，不构成环的部分，故这两个操作都不会对环$(L \backslash U) \cup \{x_E\}$产生影响。
	
	综合上面的证明，可以得到$(X \cup Y) \cap Atoms(P)$能满足这些被$U$破坏的环，联系之前的分析，$(X \cup Y) \cap Atoms(P)$能满足$P$中的所有环公式。\quad
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%% proof top


在明确了新的$top$的有效性和直观作用后，本文将对定义\ref{asp_solution}的重定义，给出新的逻辑程序$P$基于原子集$U$的方案（$Solution$）。
\begin{definition}\label{new_solution}
	给定正规逻辑程序$P$和原子集$U$，$P$基于$U$的方案（$Solution$）是一组原子集$\langle X,Y \rangle$，其中：	
	\begin{itemize}
		\item $X$是$b_U(P) \cup EC_U(P)$的一个回答集；
		\item $Y$是$e_U(t_U(P,X),X) \cup ECC_U(P,X)$的一个回答集。
	\end{itemize}
\end{definition}

下面给出一个计算逻辑程序$P$基于原子集$U$的方法的例子。
\begin{example}
	继续使用逻辑程序$P_1$，并令分割集$U=\{a\}$，根据定义\ref{in_out}可以计算得到：
	\begin{eqnarray}
		in_U(P_1) = \{ a~\leftarrow~c,~d. \}	\\
		out_U(P_1) = \{ c~\leftarrow~a. \}
	\end{eqnarray}
	
	且可以从$P_1$中取环$L=\{a,c\}$，则有$E = L \cap U = \{a\}$，满足$E \subset L$。并由例\ref{example_3_2}已经算得：
	\begin{equation}
		\Gamma (b_U(P_1) \cup EC_U(P_1)) = \{ \{ a,c,d \}, \{ a,c,d' \}, \{ a,c',d' \}, \{ c',d \} \}
	\end{equation}
	
	这里，取$X = \{a,c,d'\}$和$X' = \{a,c,d\}$，那么可以计算得到：
	\begin{eqnarray}
		R^-(E,P_1,X) = \{ a~\leftarrow~not~d. \}	\\
		R^-(E,P_1,X') = \{ a~\leftarrow~c,~d. \}
	\end{eqnarray}
	
	则有：
	\begin{eqnarray}
		SL_U(P_1,X) = \emptyset	\\
		SL_U(P_1,X') = \{ \{a\} \}
	\end{eqnarray}
	
	并基于定义\ref{new_top}计算得到：
	\begin{eqnarray}
		t_U(P_1,X) = \{ d~\leftarrow~not~c.~c~\leftarrow~a. \}	\\
		t_U(P_1,X') = \{ d~\leftarrow~not~c.~x_{\{a\}}~\leftarrow~c,~d.~c~\leftarrow~x_{\{a\}},~a. \}
	\end{eqnarray}
	
	另外，有：
	\begin{eqnarray}
		ECC_U(P_1,X) = \{ \leftarrow~not~c.~\leftarrow~d. \}	\\
		ECC_U(P_1,X') = \{ \leftarrow~not~c.~\leftarrow~not~d. \}
	\end{eqnarray}
	
	通过求解器计算得到：
	\begin{eqnarray}
		\Gamma (e_U(t_U(P_1,X),X) \cup ECC_U(P_1,X)) = \{ \{c\} \}	\\
		\Gamma (e_U(t_U(P_1,X'),X') \cup ECC_U(P_1,X')) = \emptyset
	\end{eqnarray}
	
	其中$\langle X,\{c\} \rangle$为$P$基于$U$的一个方案。
\end{example}

在有了新的方案的定义后，本文提出一个引理，具体如下：
\begin{lemma}\label{lemma_3_1}
	对任意的正规逻辑程序$P$和原子集$U$，如果$\langle X,Y \rangle$是$P$基于$U$的一组方案，且$SL_U(P,X) = \emptyset$，那么$(X \cup Y) \cap Atoms(P)$是逻辑程序$P$的一个回答集。
\end{lemma}

\begin{proof}
	根据前面已提及的$SL_U(P,X)$的属性，如果一个$smei-loop~E$属于$SL_U(P,X)$，则表示存在一个环$L$，有$E \subset L$，且$X \nvDash LF(L,P)$。所以在$SL_U(P,X) = \emptyset$时，可以得到：在逻辑程序$P$中不存在环$L$满足以下三点：
	\begin{itemize}
		\item $L \cap U = \emptyset$，
		\item $L \cap (Atoms(P) \backslash U) \neq \emptyset$，
		\item $X \cup Y \nvDash LF(L,P)$。
	\end{itemize}
	
	所以可以进一步得到$(X \cup Y) \cap Atoms(P)$满足$P$中的所有环公式。而命题\ref{satisfy_proposition}中指出$(X \cup Y) \cap Atoms(P)$是$P$的模型，联合Lin和Zhao的环理论，即定理\ref{Lin_Zhao_loop_theorem}，可以知道$P$的模型若能满足其所有环公式，则是$P$的一个回答集，所以可以得到$S = (X \cup Y) \cap Atoms(P)$是$P$的一个回答集。\quad
\end{proof}


%%%						新分割集理论								%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
更进一步地，本文依据新的程序分割方法，提出新的分割理论。
\begin{theorem}[新分割理论]\label{new_splitting_theorem}
	已知正规逻辑程序$P$和原子集$U$，一个原子集$S$是$P$的回答集，当且仅当$S = (X \cup Y) \cap Atoms(P)$，其中$\langle X,Y \rangle$是$P$基于$U$的某组方案。
\end{theorem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


在定理\ref{new_splitting_theorem}中给出的新分割理论实质上是跟Lifschitz和Turner当初提出的分割理论是一样的。本质上的不同在于定义来计算$P$基于$U$的方案$\langle X,Y \rangle$的运算符的不同。以下给出定理\ref{new_splitting_theorem}的证明。
\begin{proof}\label{proof_new_splitting_theorem}
	%%%% 充分性
	$(\Rightarrow) \space$ 即证明当$X$和$Y$是$P$基于$U$的一组方案时，$(X \cup Y) \cap Atoms(P)$是$P$的回答集。根据证明\ref{proof_top}可以知道有$(X \cup Y) \cap Atoms(P)$能满足$P$中的所有环公式。故只要证明$(X \cup Y) \cap Atoms(P)$满足$P$即可。
	
	$X$是$b_U(P) \cup EC_U(P)$的回答集，所以有$X \cap Atoms(P)$满足$b_U(P)$中的所有规则。
	
	$Y$是$e_U(t_U(P,X),X) \cup ECC_U(P,X)$的回答集。并且在$e_U(t_U(P,X),X) \cup ECC_U(P,X)$中引入的新原子$x_E$满足$\{ x_E~|~E \in SL_U(P,X) \} = Y \backslash Atoms(P)$，则有$Y$满足$e_U(P \backslash b_U(P),X)$中的所有规则。所以有$(X \cup Y) \cap Atoms(P)$满足$P \backslash b_U(P)$。
	
	综合上面两个情况，可以有$(X \cup Y) \cap Atoms(P)$满足$P$。所以有$(X \cup Y) \cap Atoms(P)$是$P$的回答集。故充分性成立。
	
	
	
	%%% 必要性
	$(\Leftarrow) \space$ 即证明当原子集$S$是$P$的回答集时，存在$X$和$Y$是$P$基于$U$的一组方案，同时有$S = (X \cup Y) \cap Atoms(P)$。令：
	\begin{equation}
		\begin{array}{rcl}
			X = (S \cap U) \cup \{ a~|~a \in S \cap Atoms(b_U(P) \backslash U) \} \\
			\cup \{ a'~|~a' \in Atoms(b_U(P)) \backslash (U \backslash S) \}
		\end{array}
	\end{equation}
	\begin{equation}
		Y = (S \backslash U) \cup \{ x_E~|~E \in SL_U(P,X) \}
	\end{equation}
	
	
	显然有$(X \cup Y) \cap Atoms(P) = S$，接着证明$\langle X, Y \rangle$是$P$基于$U$的一组方案。
	
	首先证明$X$是$b_U(P) \cup EC_U(P)$的回答集。$X$中的$(S \cap U) \cup \{ a~|~a \in S \cap Atoms(b_U(P) \backslash U) \}$即$Atoms(b_U(P))$中作为$P$回答集的部分，$\{ a'~|~a' \in Atoms(b_U(P)) \backslash (U \cup S) \}$即$Atoms(b_U(P))$中非$P$的回答集的部分，故可以有$X$满足$b_U(P) \cup EC_U(P)$。而对于任意$b_U(P) \cup EC_U(P)$中的环$L$，由于$EC_U(P)$中的规则不会产生环，所以$L$在$b_U(P)$内，所以有$R^-(L, b_U(P) \cup EC_U(P) = R^-(L,P)$。又由于$S$满足$P$中的所有环公式$LF(L,P)$，所以$X$满足$b_U(P) \cup EC_U(P)$中的所有环公式$LF(L,b_U(P) \cup EC_U(P))$。故$X$是$b_U(P) \cup EC_U(P)$的回答集。
	
	接着证明$Y$是$e_U(t_U(P,X),X) \cup ECC_U(P,X)$的回答集。${x_E~|~E \in SL_U(P,X)}$是用于在$t_U(P,X)$中构造环的，而且这些环都需要被满足，所以$x_E$必在$top$部分的回答集中，而$S$为$P$的回答集，所以能够得到$Y$满足$e_U(t_U(P,X),X) \cup ECC_U(P,X)$。接着证明$Y$满足$e_U(t_U(P,X),X) \cup ECC_U(P,X)$中的所有环公式。
	
	根据前面的分析可知，$e_U(t_U(P,X),X) \cup ECC_U(P,X)$中的环分为两种情况。
	
	1）$L \subseteq Atoms(P) \backslash U$，即原程序$P$中本来就在$P \backslash b_U(P)$中的环。即不存在$x_E \in L$。这种情况下的环，由于$L \cap U = \emptyset$，故$e_U(t_U(P,X),X)$只删去$U$中相关原子，同时，$ECC_U(P,X)$只有限制规则，不会产生环，所以两种情况都不会影响到$L$。而$t_U(P,X)$中的第二部分只对满足$head(r) \cap U \neq \emptyset$的规则进行修改，故也不对$L$造成影响。而$S$是原程序$P$的回答集，且$L \cap U = \emptyset$，故$S \backslash U$可以满足这些环的环公式，故$Y$也能满足这些环的环公式。
	
	2）当存在$x_E \in L$时，根据前面的结论可知，含有$x_E$的环$L$都为了原程序中被$U$分割开的环$L'$所构造的。有构造的新环$L = (L' \backslash U) \cup \{ x_E \}$。若$Atoms((L' \backslash U) \cup \{ x_E \}) \nsubseteq (S \backslash U) \cup \{ x_E \}$（即$Y$），则根据环公式被满足的定义有$Y$满足该环公式。若$Atoms((L' \backslash U) \cup \{ x_E \}) \subseteq (S \backslash U) \cup \{ x_E \}$，而$S$为原程序$P$的回答集，所以$S$满足$P$中所有的环公式。而$(L' \backslash U) \cup \{ x_E \}$在$P \backslash b_U(P)$的外部支持也是$L'$的外部支持。故$(S \backslash U)$也满足$(L' \backslash U) \cup \{ x_E \}$的某个外部支持。所以$(S \backslash U) \cup \{ x_E \}$，即$Y$满足$e_U(t_U(P,X),X) \cup ECC_U(P,X)$中的所有环公式。
	
	所以$Y$是$e_U(t_U(P,X),X) \cup ECC_U(P,X)$的回答集。故必要性成立。\quad
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%  证明新的分割理论的正确性  %%%%%%%%%%%%%%%%%%%%%%%%



$SL_U(P,X)$根据Lin和Zhao的环理论，定义的让底部回答集$X$所不能满足的环公式的环与分割集的交集所构成的半环。定义这些半环的目的就是为了依据它们构造出能保证$X$为真的规则。然而，更进一步地，基于Ji和Wan等在环理论的基础下提取出特征环（$Proper~Loop$）的思想下，可以想象得到并非所有的半环都是必要的，本文在此根据Ji和Wan等的思想，提取出必要的半环，定义一个$SL_U(P,X)$的子集以指代必须的半环集合。
\begin{definition}[关键半环（$Dominated~Semi-loop$）]\label{dominated_semi_loop}
	给定正规逻辑程序$P$和原子集$U$，一个半环$E$被称为关键半环，当且仅当存在另一个半环$E'$满足$E' \subseteq E$，且有$E' \cap head(in_U(P)) = E \cap head(in_U(P))$，以及$E' \cap body^+(out_U(P)) = E \cap body^+(out_U(P))$，同时称$E$能代表$E'$。
\end{definition}

根据关键半环的特性，因为关键半环能涵盖其所代表的半环的头部和体部正原子，所以关键半环的环公式可以推出其所能代表的半环的环公式。由于关键半环能够代替其他半环，所以这里定义一个关键半环的集合。
\begin{definition}[关键半环集]\label{DSL_U_PX}
	给定析取逻辑程序$P$和原子集$U$，$P$关于$U$的关键半环集记为$DSL_U(P,X)$，并定义为以下集合：
	\begin{equation}
		\begin{array}{rcl}
			DSL_U(P,X) = \{ E~|~E \in SL_U(P,X)~and~there~dose~not~\\
			exist~another~E' \in SL_U(P,X)~s.t.~E~is~dominated~by~E'\}
		\end{array}
	\end{equation}		
\end{definition}

本文在此提供一个计算$DSL_U(P,X)$的算法$Algorithm$\ref{DSLUPX}。

% 插入算法
\RestyleAlgo{ruled}\LinesNumbered\input{algorithm/DSLUPX.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 算法分析
算法分析：

根据$DSL_U(P,X)$的定义可知，只需关注$head(in_U(P))$和$body^+(out_U(P))$，因为这两部分会影响环公式能否被满足。故上述算法最外层对$head(in_U(P))$和$body^+(out_U(P))$的所有子集进行遍历。算法把原程序$P$中的原子分为两部分：$AP_1 = Atoms(P) \backslash (head(in_U(P)) \cup body^+(out_U(P))$和$AP_2 = head(in_U(P)) \cup body^+(out_U(P)$。算法基于$AP_1 \cup S_1 \cup S_2$从$P$的正依赖图$G_P$中提取子图$G^S_P$，并查找$G^S_P$中包含$S_1 \cup S_2$的强连通分量（$SCC$）$L$。强连通分量保证其是一系列环中在集合意义上是最大的一个，同时根据其满足$S_1 \cup S_2 \subseteq L$，所以$L$的任意非空子集$E$都满足：
\begin{eqnarray}
	E \cap head(in_U(P)) \neq \emptyset~,~E \cap head(in_U(P)) = L \cap head(in_U(P)) \\
	E \cap body^+(out_U(P)) \neq \emptyset~,~E \cap body^+(out_U(P)) = L \cap body^+(out_U(P))
\end{eqnarray}

故这样的强连通分量$L$若不存在，则可以跳过当前的$G^S_P$子图，继续尝试下一个。如果存在强连通分量$L$，则进一步判断其是否满足以下条件，以确定当前的$L$是否$SL_U(P,X)$中的元素。
\begin{equation}\label{slupx_conditions}
	L \cap U \subseteq X~,~R^-(L \cap U, P, X) \subseteq in_U(P)
\end{equation}

如果满足条件，则$L \cap U$是$DLS_U(P,X)$中的元素，加入到$dsl$中。如果不满足，找出不满足的导致不满足$SL_U(P,X)$条件的原子：
\begin{equation}
	S = head(R^-(L \cap U, P, X) \backslash in_U(P)) \cup ((L \backslash U) \backslash X)
\end{equation}

令$G^S_P$是$G_P$关于$L \backslash S$的子图，即可能满足条件\ref{slupx_conditions}的原子子图。并从该子图中重复寻找强连通分量$L$及判断其是否满足条件的过程。
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



基于$DSL_U(P,X)$，本文定义关键顶部（$Dominated~Top$）和关键方案（$Dominated~Solution$），它们的具体内容就是通过把其中用到的$SL_U(P,X)$替换为$DSL_U(P,X)$，并记关键顶部为$dt_U(P,X)$。最后本节扩展新的分割集理论，得到以下定理。
\begin{theorem}\label{new_d_splitting_theorem}
	给定一个正规逻辑程序$P$和原子集$U$，一个原子集$S$是$P$的一个回答集，当且仅当$S = (X \cup Y) \cap Atoms(P)$，其中$\langle X,Y \rangle$是$P$基于$U$的某组关键方案。
\end{theorem}

对于$bottom$部分，通过新定义$EC_U(P)$来补充$Atoms(b_U(P)) \backslash U$中原子真值的可能性，以保证这部分原子不会被忽略。

对于$top$部分，定义了$ECC_U(P,X)$来在$top$中确保$bottom$部分的回答集中的原子必为真。同时使用环理论，引入$smei-loop$的集合$SL_U(P,X)$，其代表的是环公式不能被底部回答集所满足的环所相关的$smei-loop$集合。基于$SL_U(P,X)$和原来的$P \backslash b_U(P)$来构建出新的$top$，即定义\ref{new_top}中的$t_U(P,X)$。

在上述的定义和分析证明过程中可以明确地知道新的程序分割方法能对任意原子集构成的分割集都有效。

在给出了正规逻辑程序的新程序分割方法后，下一节中将新的程序分割方法扩展到析取逻辑程序中。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{析取逻辑程序分割方法}

本小节将把新的程序分割方法从正规逻辑程序扩展到析取逻辑程序。由于之前所定义下的规则集合都是基于普遍规则所定义的，只是在分析证明时用了正规逻辑程序的性质，所以对于析取逻辑程序，这些规则集合的操作符依旧有用。

具体地，$b_U(P)$，$e_U(P,X)$，$EC_U(P)$，$ECC_U(P,X)$，$in_U(P)$，$out_U(P)$，$SL_U(P,X)$和$DSL_U(P,X)$都保持原来的定义不变。跟正规逻辑程序有所不同的是，在析取逻辑程序中，$in_U(P) \cap out_U(P) \neq \emptyset$。
在明确了需要用到的基本概念后，本文将重新定义析取逻辑程序的$top$部分，依旧标记为$t_U(P,X)$。

\begin{definition}[析取逻辑程序的$top$]\label{dlp_top}
	给定一个析取逻辑程序$P$和原子集$X$，$U$，$P$基于$U$关于$X$的$top$记为$t_U(P,X)$，并由以下三部分组成：
	\begin{itemize}
		\item $P \backslash (b_U(P) \cup out_U(P)$，
		\item $\{ \{x_E\} \cup head(r) \backslash E~\leftarrow~body(r)~|~r \in in_U(P)~and~r \in R^-(E,P,X) \},~for~each~E \in SL_U(P,X)$，
		\item $\{ head(r)~\leftarrow~x_{E_1},x_{E_2},...,x_{E_t},body(r)~|~r \in out_U(P),~for~all~possible~E_i \in SL_U(P,X)(1 \leq i \leq t)~s.t.~body^+(r) \cap E_i \neq \emptyset \}$。
	\end{itemize}
\end{definition}

%这里给出如此定义析取逻辑程序的$t_U(P,X)$的有效性的证明。
\begin{proof}\label{proof_dlp_top}
	析取逻辑程序的$t_U(P,X)$与正规逻辑程序的差别只在第二部分。在正规逻辑程序中，对于$head(r) \cap E \neq \emptyset$的情况下，由于$|head(r)| = 1$，所以实际为$head(r) \in E$。故在正规逻辑程序的$t_U(P,X)$的第二部分直接用$x_E$替换原来的$hear(r)$即可。而在析取逻辑程序中$|head(r)| >= 1$，所以不能直接用$x_E$替换原来的$hear(r)$。而是直接把$head(r) \cap E$部分替换为$x_E$，故头部修正为$\{x_E\} \cup (head(r) \backslash E)$。
	
	同时，由于$x_E$的存在，依旧能保持环的构成。第三部分中规则的$head(r)$本来就不需要修改，所以这部分析取逻辑程序和正规逻辑程序是一致的。此外，构成$(L \ U) \cup \{ x_E \}$环后的有效性跟正规逻辑程序一致。\quad
\end{proof}

在证明析取逻辑程序的$top$的有效性后，关于一个析取逻辑程序$P$基于一个原子集$U$的方案定义依旧，只是相应的$t_U(P,X)$修改为定义\ref{new_top}中的。同时，基于上述的分析和证明，本文给出关于析取逻辑程序在程序分割理论下的回答集定理。
\begin{theorem}\label{dlp_splitting_theorem}
	给定析取逻辑程序$P$和原子集$U$，一个原子集$S$是$P$的一个回答集，当且仅当$S = (X \cup Y) \cap Atoms(P)$，其中$\langle X,Y \rangle$是$P$基于$U$的某组方案。
\end{theorem}

联合析取逻辑程序的$t_U(P,X)$的有效性的证明和3.2.1中关于定理\ref{new_splitting_theorem}的证明可以直接地得到定理\ref{dlp_splitting_theorem}的正确性。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{强程序分割方法}

在Lifschitz和Turner的分割理论中，分割集U把逻辑程序$P$分割为$b_U(P)$和$P \backslash b_U(P)$两部分，原逻辑程序的回答集可以通过这两部分的回答集来求解得到。除了这个直接面对回答集求解的特性之外，Lifschitz和Turner的分割理论还能引申出来其他的特性。对此，本文总结出如下命题。
\begin{proposition}\label{proposition_3_2}
	给定逻辑程序$P$，原子集$U$是$P$在Lifschitz和Turner的分割理论定义下的分割集。另有逻辑程序$P'$满足$Atoms(P') \cap U = \emptyset$则原子集$S$是逻辑程序$P \cup P'$的一个回答集，当且仅当$S = X \cup Y$，其中$X$为$b_U(P)$的某个回答集，$Y$为$e_U(P \backslash b_U(P),X) \cup P'$的某个回答集。
\end{proposition}

\begin{proof}
	由于$Atoms(P') \cap U = \emptyset$，且$\Gamma (b_U(P)) \subseteq U$，所以$\Gamma (P') \cap \Gamma (b_U(P)) = \emptyset$，同时有$\Gamma (P') \cap U = \emptyset$。所以$P \cup P'$中划分出的$b_U(P)$依旧具有命题封闭性，其回答集依旧不受$(P \cup P') \backslash b_U(P)$影响。
	
	又在$Atoms(P') \cap U = \emptyset$及$Atoms(b_U(P)) \subseteq U$情况下，可以得到：	
	\begin{equation}
		(p \cup P') \backslash b_U(P) \equiv (P \backslash b_U(P)) \cup P'
	\end{equation}
	
	而$e_U(P,X)$操作中只会依旧条件删去与$U$有关的文字以保证$X$中的原子的真值确定性。所以在$Atoms(P') \cap U = \emptyset$情况下，$e_U(P,X)$不需要对$P'$操作，而$P'$所能推出的结论也不会干扰$P \backslash b_U(P)$或受其干扰，所以$e_U(P \backslash b_U(P),X) \cup P'$可以求解出$P \cup P'$的另一部分回答集。
	
	综上所述，可以得到命题\ref{proposition_3_2}的正确性。\quad
\end{proof}

然而，对于本文所关注和扩展的使用任意原子集作为分割集时，命题\ref{proposition_3_2}并不成立。但基于这个思想，为了继续扩展分割集理论对逻辑程序的结合律有效，本文提出了强程序分割方法（$Strong~Splitting~Method$）。为此，本文对$SL_U(P,X)$进行了扩展。
\begin{definition}\label{SS_U_PX}
	给定析取逻辑程序$P$以及原子集$X$和$U$，标记以下原子集的集合：
	\begin{equation}
		\begin{array}{rcl}
			SS_U(P,X)~=~\{ E~|~E~is~an~nonempty~subset~of~U,~ \\
			E \subseteq X~and~R^-(E,P,X) \subseteq in_U(P) \}
		\end{array}		
	\end{equation}
\end{definition}

很直观地，$SS_U(P,X)$把$SL_U(P,X)$从$P$关于$U$的$smei-loop$扩展到$U$的任意非空子集。同时，对任何满足$Atoms(P') \cap U = \emptyset$的析取逻辑程序$P'$。$P'$与$U$没有交集，故不会影响判断$E \subseteq X$和$R^-(E,P,X) \subseteq in_U(P)$等条件，故其对$SL_U(P,X)$中的元素没有附加限制，而且$SS_U(P,X)$中的$E$扩展为$U$的任意非空子集。故可以得到$b_U(P \cup P') = b_U(P)$，且对任意的原子集$X$有$SL_U(P \cup P',X) \subseteq SS_U(P,X)$。此外，若$U$是Lifschitz和Turner的分割理论定义下的分割集，则对任意原子集$X$都有$SS_U(P,X) = \emptyset$。基于$SS_U(P,X)$，本文提出了析取逻辑程序$P$基于原子集$U$关于原子集$X$的强顶部（$Strong~Top$）。
\begin{definition}[强顶部（$Strong~Top$）]\label{strong_top}
	给定析取逻辑程序$P$以及原子集$X$和$U$，记$P$基于$U$关于$X$的强顶部（$Strong~Top$）为$st_U(P,X)$，其由以下三部分组成：
	\begin{itemize}
		\item $P \backslash (b_U(P) \cup out_U(P)$，
		\item $\{ \{x_E\} \cup head(r) \backslash E~\leftarrow~body(r)~|~r \in in_U(P)~and~r \in R^-(E,P,X) \},~for~each~E \in SS_U(P,X)$，
		\item $\{ head(r)~\leftarrow~x_{E_1},x_{E_2},...,x_{E_t},body(r)~|~r \in out_U(P),~for~all~possible~E_i \in SS_U(P,X)(1 \leq i \leq t)~s.t.~body^+(r) \cap E_i \neq \emptyset \}$。
	\end{itemize}
\end{definition}

在给出$st_U(P,X)$后，本文定义一个析取逻辑程序$P$关于原子集$U$的强方案（$Strong~Solution$）。
\begin{definition}[强方案（$Strong~Solution$）]\label{strong_solution}
	给定析取逻辑程序$P$和原子集$U$，$P$关于$U$的强方案为一个原子集组合$\langle X,Y \rangle$，其中$X$和$Y$满足：
	\begin{itemize}
		\item $X$是$b_U(P) \cup EC_U(P)$的一个回答集；
		\item $Y$是$e_U(st_U(P,X),X) \cup ECC_U(P,X)$的一个回答集。
	\end{itemize}
\end{definition}

在有了强方案的定义后，依据$SS_U(P,X)$对$SL_U(P,X)$性质的扩展，可以得到以下两个定理。
\begin{theorem}\label{strong_splitting_theorem}
	给定析取逻辑程序$P$和原子集$U$。一个原子集$S$是$P$的一个回答集，当且仅当$S = (X \cup Y) \cap Atoms(P)$，其中$\langle X,Y \rangle$是$P$基于$U$的某组强方案。
\end{theorem}

\begin{theorem}\label{strong_associative}
	给析取定逻辑程序$P$和原子集$U$。另有逻辑程序$P'$满足$Atoms(P') \cap U = \emptyset$。则原子集$S$是逻辑程序$P \cup P'$的一个回答集，当且仅当$S = (X \cup Y) \cap Atoms(P)$，其中$X$为$b_U(P) \cup EC_U(P)$的某个回答集，$Y$为$e_U(st_U(P,X),X) \cup ECC_U(P,X) \cup P'$的某个回答集。
\end{theorem}

\begin{proof}
	由于$P'$跟$U$无关，所以$b_U(P \cup P') = b_U(P)$，故一样可以把$P \cup P'$通过$U$来分割，而不造成$bottom$的影响，$P$只影响$top$部分。而$P$的影响就是会造成原来在$P \backslash b_U(P)$中不是环的原子集变成了环，所以直接修改$SS_U(P,X)$为$U$中任意被破坏的非空子集。这些非空子集是可能因为$P'$而被构成环的。
	
	因为$Atoms(P') \cap U = \emptyset$，所以对$(P \cup P') \backslash b_U(P)$进行$ct_U(P,X)$和$e_U(P,X)$操作的话，实际上$P'$中的规则不会被操作，这是因为$ct_U(P,X)$只对与$E \subseteq U$有关的规则操作，$Atoms(P') \cap U = \emptyset$，所以$Atoms(P') \cap E = \emptyset$，而$e_U(P,X)$只对与$U$相关的规则操作，所以也不会涉及$P'$中的规则。故只需对$P$执行，并在最后加上$P'$。
	
	所以对于$e_U(st_U(P,X),X) \cup ECC_U(P,X)$这部分，它保证了所有不被$X$满足的环公式的子集都被构造出相应的环，而且这些环会被满足，此外，去掉了$X$带来的原子真值确定性影响。在$e_U(st_U(P,X),X) \cup ECC_U(P,X)$中加入$P'$后求得的回答集$Y$与$X$结合就是这部分所能满足原程序所有环公式的回答集。\quad
\end{proof}

定理\ref{strong_associative}把程序分割方法的结合性扩展到以任意原子集作为分割集的情况。而这种结合性的本质是一个二次分割，这种扩展有助于程序分割方法的递归问题研究。



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{计算复杂性分析}

在上一节中，本文详细地给出了正规逻辑程序和析取逻辑程序的新程序分割方法，并证明了新的程序分割方法对任意原子集构成的分割集都有效。当真正的自由是规矩。任意原子集给了程序分割很大的自由度，但这更多是理论层面的。本节将分析讨论分割集如何影响着程序分割过程的计算复杂性，并指出怎样的原子集作为分割集才会让程序分割更高效。此外，由于析取逻辑程序跟正规逻辑程序的本质区别在于头部的基，即头部中原子的数量。所以本节以正规逻辑程序在程序分割方法上的计算复杂性为例进行分析。

对于一个正规逻辑程序$P$通过一个原子集U进行程序分割后被划分为底部和顶部两部分，而程序分割过程中主要耗时的有两个地方，分别为底部的$EC_U(P)$和顶部的$SS_U(P,X)$所造成。具体体现为以下两个问题：
\begin{enumerate}
	\item 在底部中，$EC_U(P)$中的规则在最坏情况下会为$b_U (P) \cup EC_U(P)$带来$2^{|Atoms(b_U(P) \backslash U|}$个回答集，这是一种指数爆炸的极端；
	\item 在顶部中，$DSL_U(P,X)$中的半环会为$dt_U(P)$引入指数爆炸数量的新原子。
\end{enumerate}

接下来的小节将分别对上述两个问题进行具体的分析和给出提速方案。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{底部计算复杂性}

本小节主要对第一个问题进行分析。底部中的$EC_U(P)$是为了补充$Atoms(b_U(P)) \backslash U$中的原子在回答集中的真值可能性而定义的。对于$EC_U(P)$带来的耗时，本节给出以下两个降低计算复杂性的方法：
\begin{itemize}
	\item 保证$|Atoms(b_U(P)) \backslash U|$足够小，最好是在某个常数值以内；
	\item 让分割集$U$中的原子能被逻辑程序$P$的每个回答集所满足。
\end{itemize}

\begin{proof}
	第一个方法中，在$|Atoms(b_U(P)) \backslash U|$足够小的情况下，特别地，是保持在某个常数值以内的话，$2^{|Atoms(b_U(P)) \backslash U|}$的大小便会被限制，这样就能防止底部回答集数量因为引入的新原子而造成指数爆炸。这是一个非常直观的措施。此外，由于分割集能够是任意原子集，所以限制$|Atoms(b_U(P)) \backslash U|$的大小是具备可行性的。
	
	第二个方法中，若能使得分割集$U$中的原子能被逻辑程序P的每个回答集所满足，那么这在后续计算顶部的$dt_U(P)$时只需考虑$b_U(P) \cup EC_U(P)$中满足$U \subseteq X$的回答集$X$。这样就能大大降低$dt_U(P)$的复杂性。	\quad
\end{proof}

需要明确的一点是，能被逻辑程序$P$的每个回答集所满足的原子集有独立的定义和算法，不需要求解出逻辑程序的所有回答集才能得到。所以找出这样的原子集去作为分割集是可行的。而这样的原子集也将给本文带来分割集应用的新思路。具体的定义和算法将会在第四章给出。



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{顶部计算复杂性}
本小节主要对第二个问题进行分析。关于顶部中$DSL_U(P,X)$所带来的复杂性，依据其定义可以知道其中的关键半环$E$与其所能代表的半环$E'$必须满足：
\begin{eqnarray}
	E \cap head(in_U(P)) = E' \cap head(in_U(P)) \\
	E \cap body^+(out_U(P)) = E' \cap body^+(out_U(P))
\end{eqnarray}

而关键半环本来是可以代表其他一般半环，此外，半环也是由一般的环交分割集而来，所以保证不存在两个不同的关键半环可以同时代表一个一般半环的情况。在关键半环的互斥性之下，关键半环的数量的理论最大值将由$head(in_U(P))$和$body^+(out_U(P))$的基所决定。

具体来说就是$E \cap head(in_U(P))$和$E \cap body^+(out_U(P))$的可能情况数量所决定。设$n = |head(in_U(P))|$和$m = |body^+(out_U(P))|$，那么有：
\begin{equation}
	|E \cap head(in_U(P))| \leq \sigma_{0 \leq i \leq n} C^i_n = 2^n
\end{equation}

其中$C_n^i$为排列组合中的组合计算符号。同理，还有：
\begin{equation}
	|E \cap body^+(out_U(P))| \leq 2^m
\end{equation}

故有：
\begin{equation}
	|DSL_U(P,X)| \leq |E \cap head(in_U(P))| * |E \cap body^+(out_U(P))| \leq 2^n * 2^m
\end{equation}

实际上，上述的$|DSL_U(P,X)|$规模结论也能从其算法中得到。从上述的结论中可以明显地知道通过限制$|head(in_U(P))|$和$|body^+(out_U(P))|$的大小可以限制$|DSL_U(P,X)|$的大小。而$|head(in_U(P))|$和$|body^+(out_U(P))|$的大小依旧可以通过分割集$U$来限制。而限制$|DSL_U(P,X)|$的大小后，在$dt_U(P)$中的第二和第三部分中将会大大减少新原子的引入，进而降低程序规模，加快求解速度。

上述的计算复杂性都是基于正规逻辑程序而进行的。而事实上，正规逻辑程序的程序分割的计算复杂性的相关结论可以应用于析取逻辑程序上。因为两者仅在规则头部的基上有所不同，同时头部原子为析取关系。



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{本章小结}

本章给出了Lifschitz和Turner的分割集理论的证明，并提出了在正规逻辑程序中对任意原子集作为分割集都有效的新程序分割方法，并把这个方法推广到析取逻辑程序。此外，在分析程序分割方法的计算复杂性时，引申出通过程序结论来扩展新分割理论的应用场景，这个应用场景将紧接着在下一章描述。


