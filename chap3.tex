\chapter{新分割集与程序分割}

本章基于对Lifschitz和Turner提出的分割集和程序分割理论的分析，提出了新的分割集和程序分割方法。实际上是提出了一个可以对任意原子集作为分割集都有效的程序分割方法。本章将分别给出正规逻辑程序和析取逻辑程序的新程序分割方法，然后提出一个强程序分割方法。最后以正规逻辑程序的程序分割方法为例，对新的程序分割方法的计算复杂性进行分析，并指出主要性能瓶颈所在及改进思路。


\section{新分割集}

在给出新分割集之前，本文将对Lifschitz和Turner提出的分割集理论进行分析，然后基于他们对分割集的定义提出一个计算分割集的算法，并对ASP竞赛中的程序进行计算，对计算结果进行分析，随后给出本文定义的新分割集。

\begin{definition}\label{hh_dh}
	hhh
\end{definition}

\subsection{原有分割集和程序分割的分析证明}

Lifschitz和Turner给出的分割集定义是：一个原子集$U$称为一个逻辑程序$P$的分割集，当且仅当对$P$中的所有规则$r$都有$head(r) \cap U \neq \emptyset$蕴涵$Atoms(r) \subseteq U$。这个分割集定义的直观含义就是一个分割集若包含规则头部的原子，则也可以包含该规则的所有原子。这样的性质保证了分割集$U$可以把原程序从结构上划分成两部分，进而保证了原程序的回答集可以从分割后的两部分的回答集求解得到。Lifschitz和Turner在1994年的原文中只给出了程序分割方法的定义，即根据定义(\ref{asp_solution})分别求出底部$b_U(P)$和化简后的顶部$e_U(t_U(P),X)$的回答集$X$和$Y$，根据方案$\langle X,Y \langle$得到原程序的回答集。本文在这里补充给出这种分割方法的可行性证明。关于Lifschitz和Turner的程序分割方法可行性的证明如下。



\begin{proof}
首先证明分割集可以把逻辑程序划分为回答集互斥的两部分，并且底部的回答集是原逻辑程序回答集子集。

根据定义\ref{splitting_set}，分割集$U$满足对于逻辑程序$P$中任意的规则$r$都有，$head(r) \cap U \neq \emptyset$蕴涵$Atoms(r) \subseteq U$。而根据定义\ref{bottom_top}有：	
\begin{eqnarray}
	b_U(P) = \{ r \in P~|~head(r) \cap U \neq \emptyset \}	\\
	t_U(P) = P~\backslash~b_U(P)
\end{eqnarray}

根据分割集$U$的特性，可以知道：$Atoms(b_U(P)) \subseteq U$，并定义：
\begin{eqnarray}
	head(t_U(P))~=~\bigcup_{r \in t_U(P)} head(r)	\\
	body(t_U(P))~=~\bigcup_{r \in t_U(P)} body(r)
\end{eqnarray}

另，记一个逻辑程序$P$的回答集为$\Gamma (P)$，而回答集必是一个逻辑程序的头部原子的子集，即$\Gamma (P) \subseteq head(P)$。根据$t_U(P)$的定义可以知道：	
\begin{eqnarray}
	head(t_U(P)) \subseteq Atoms(P) \backslash U \\
	\Gamma (b_U(P)) \subseteq U
\end{eqnarray}
由于$head(t_U(P)) \cap U = \emptyset$，所以$\Gamma (t_U(P)) \cap U = \emptyset$，故有$\Gamma (b_U(P)) \cap \Gamma (t_U(P)) = \emptyset$，这样保证了$b_U(P)$和$t_U(P)$的回答集是互斥的。此外，我们已知：	
\begin{eqnarray}
	Atoms(b_U(P)) \subseteq U \\
	head(t_U(P)) \subseteq Atoms(P) \backslash U \\
	head(b_U(P)) \cap head(t_U(P)) = \emptyset
\end{eqnarray}

这些关系表明$b_U(P)$于原逻辑程序而言，是一个独立的模块，其回答集只能从$b_U(P)$这部分推出，因为$head(b_U(P))$中的原子不会出现在$head(t_U(P))$中，即$\Gamma (b_U(P))$中的元素不需要依赖$t_U(P)$中的规则，一旦$head(b_U(P))$中的某个元素被推出为真，那么放在整个程序它都将是真的，即它必为原程序回答集的元素，即$\Gamma (b_U(P))$中的元素必将出现在原程序的某个回答集中。

然而，并不是直接计算$b_U(P)$和$t_U(P)$的回答集就可以得到最终的回答集。因为$body(t_U(P))$中可能会包含有$U$中的原子，而如果这些原子是在$\Gamma (b_U(P))$中的话，我们是可以知道其真值的，因为$\Gamma (b_U(P))$必是原程序回答集的一部分。那么需要定义一个操作来删除这些可以肯定真值的原子。这个操作就是定义\ref{e_U_P_X}中的$e_U(P,X)$。

接着证明$e_U(P,X)$的有效性。

令$X = \Gamma (b_U(P))$。对于$X$中的原子，其在$t_U(P)$中的形式只有正文字和负文字，即$x$或$not~x$，$x \in X$。

在$e_U(P,X)$的定义中，它只保留满足以下条件的规则$r$：$body^+(r) \cap U \subseteq X$，及$(body^-(r) \cap U) \cap X = \emptyset$。并在保留下来的规则中删去所有形如$a$或$not~a$，其中$a \in U$的文字。	
\begin{enumerate}
	\item 对于满足$body^+(r) \cap U \subseteq X$的规则$r$，后续的化简操作是$body^+(r) \backslash U$，而$X \subseteq U$，且$body^+(r) \cap U \subseteq X$，所以实质的意义就是$body^+(r) \backslash X$。对于$x \in body^+(r) \cap X$，因为$x \in X$，$X = \Gamma (b_U(P))$，并且$X$必为原程序回答集的一部分，所以$x$也为原逻辑程序中某个回答集的元素，所以可以确定$x$为真，且体部为合取关系，根据$head(t_U(P)) \subseteq Atoms(P) \backslash U$，即$x$在$t_U(P)$中不会在出现在规则的头部，即在$t_U(P)$中不可能推出$x$为真，但从$X$可以确定其为真，故需要删去$x$。所以保留满足$body^+(r) \cap U \subseteq U$的规则$r$，并执行$body^+(r) \backslash U$操作。
	\item 对于满足$(body^-(r) \cap U) \cap X= \emptyset$的规则$r$，后续的化简操作是$body^-(r) \backslash U$。反向考虑，如果$(body^-(r) \cap U) \cap X \neq \emptyset$，即规则$r$的体部中包含$not~a$，$a \in X$。而从上面的说明可以知道$a \in X$，则可以判定$a$为真，即$not~a$为假（因为“推不出$a$为真”为假）。而体部为合取关系，一旦确定体部中有为假的元素，则体部为假，该规则无法推出头部为真，所以可以删去该规则，故只考虑满足$(body^-(r) \cap U) \cap X = \emptyset$的规则。此外，对于满足这个条件的规则，其$body^-(r) \cap X = \emptyset$，而对于$body^-(r)$可能存在$U \backslash X$中的元素，$U \backslash X$中的元素直接含义就是原程序回答集中推不出为真的原子，所以若$b \in U \backslash X$，则$not~b$为真。跟1中一样，体部为真的元素应该直接删去。所以保留满足$(body^-(r) \cap U) \cap X = \emptyset$的规则$r$，并执行$body^-(r) \backslash U$的操作。
\end{enumerate}	

根据上面的证明可以知道，$X$作为原程序回答集的一部分，$e_U(t_U(P),X)$利用$X$中元素的真值化简出一个计算原程序剩下回答集部分的逻辑程序。记$Y = \Gamma (e_U(t_U(P),X))$。
	
$b_U(P)$中只包含$U$中的原子，它自身是一个命题闭包，所以求解得到的回答集$X$必是原程序回答集的部分。而$e_U(t_U(P),X)$得到一个跟$U$无关的程序，同时确保了$X$中的元素为真，所以这部分求解得到的回答集$Y$就是原程序回答集剩下的部分。且有	
\begin{eqnarray}
	X \subseteq Atoms(P) \cap U	\\
	Y \subseteq Atoms(P) \backslash U
\end{eqnarray}	
	
所以$X \cap Y = \emptyset$，故$X \cup Y$是确保一致的，并且为原程序的回答集。\quad
\end{proof}


上述证明过程说明了Lifschitz和Turner提出的程序分割方法的有效性。由于$U$是一个命题闭包，它能有效地把一个逻辑程序的规则根据自己的闭包性在结构上一分为二。



\subsection{提出新的分割集}\label{section_3_1_2}

Lifschitz和Turner给出的分割集的定义实际上是一个验证型定义。他们定义一个原子集$U$是逻辑程序$P$的分割集，当且仅当$P$中的每个规则$r$满足$head(r) \cap U \neq \emptyset$蕴涵$Atoms(r) \subseteq U$。这个定义从直观上来说就是如果一个原子集合是一个逻辑程序的分割集，那么它满足逻辑程序中凡是头部与其有交集的规则，都会有该规则的所有原子都在该原子集合内。本文根据Lifschitz和Turner对分割集的定义给出了一个计算逻辑程序的分割集的算法，为$Alogrithm$\ref{LifschitzU}。

% 插入算法
\RestyleAlgo{ruled}\LinesNumbered\input{algorithm/LifschitzU.tex}

明显地，$\emptyset$和$Atoms(P)$都是任何逻辑程序的分割集。而本文把上述算法应用在ASP竞赛的逻辑程序中，得到的结果为大部分逻辑程序的分割集都是$Atoms(P)$。这样的事实说明，Lifschitz和Turner所定义的分割集从理论上是美好的，它是一个从原程序中抽取出来的命题闭包，直观来看，这样的一个命题闭包就是逻辑程序正依赖图中没有出边的子图，这样的子图不受其他命题作为外部支持，所以在求解回答集上也自封闭，具有良好的独立性。然而从ASP竞赛的逻辑程序的计算结果可以知道，实际中的程序并非都具有如此性能优良的子图。为了能让分割集的思想能应用到一般的情景下，本文对其Lifschitz和Turner的分割集理论进行了扩展。事实上，本文并没有定义一个新的分割集，而是定义了一个新的程序分割方法，并确保这个新的程序分割方法能对任意原子集构成的分割集都有效。即新的分割集被扩展为任意原子集，摆脱了原有分割集对逻辑程序的拓扑结构的强依赖性。




\section{新程序分割方法}

本节中将分别给出正规逻辑程序和析取逻辑程序的程序分割方法，这两者间的主要不同在于对顶部（$top$）的定义，这也由正规逻辑程序和析取逻辑程序的回答集语义所决定。在介绍正规逻辑程序的程序分割方法过程中，本节会在定义操作符的同时给出其直观上的含义，并证明新的程序分割方法对任意原子集构成的分割集的有效性。然后，本节会提出一个强程序分割方法，该方法是为了补充把程序分割方法在分配律下的有效性。

\subsection{正规逻辑程序分割方法}

Lifschitz和Turner的程序分割方法是基于分割集进行的，而根据\ref{section_3_1_2}的结果表明，对于大部分逻辑程序，分割集往往就是$Atoms(P)$。这样的分割集无法分割逻辑程序，所以本文提出了新的程序分割方法，以支持分割集可以为任意原子集。
首先，本文继续使用定义\ref{bottom_top}中的$b_U(P)$和定义\ref{e_U_P_X}中的操作$e_U(P,X)$，依旧记分割集为U。而此时分割集$U$并不存在命题封闭性，即：
\begin{equation}
	Atoms(b_U(P)) \subseteq U
\end{equation}

不一定成立。可以更为直接地说，大部分情况下都不再成立。为了保证新程序分割方法的普遍适用性，我们考虑：
\begin{equation}
Atoms(b_U(P)) \nsubseteq U
\end{equation}

事实上此时有效的方法对$Atoms(b_U(P)) \subseteq U$情况下一样有效，因为附加操作都是为了保证最坏情况的。

在原来的分割集下，$b_U(P)$内保证了命题封闭性，即有：
\begin{equation}
	Atoms(b_U(P)) \cap head(P \backslash b_U(P)) = \emptyset
\end{equation}

即如果$Atoms(b_U(P))$中的原子属于回答集，那么它只会在$b_U(P)$中被推出。而对于$U$为任意原子集的情况下，有：
\begin{equation}
	Atoms(b_U(P)) \backslash U \neq \emptyset
\end{equation}

所以需要考虑$Atoms(b_U(P)) \backslash U$这部分原子的真值可能性问题。而事实上，这部分原子的真值仅靠$b_U(P)$是无法确定的，因为它们可能是$P \backslash b_U(P)$中某个规则的头部，即可能会在$P \backslash b_U(P)$部分被推出。所以最直接也是最有效的方法就是在$\Gamma (b_U(P))$中加入这些不确定原子真值的全排列。然而，这些原子的真值也并非可以任意猜测，需要配合$b_U(P)$中的逻辑关系，所以本文定义了规则集合，来确保这些原子的真值在合理推导下被遍历。
\begin{definition}
	规则集合$EC_U(P)$为$Atoms(b_U(P)) \backslash U$中的原子的真值可能性提供补充规则，有：
	\begin{equation}
		EC_U(P)~=~\{ p~\leftarrow~not~p'.~p'~\leftarrow~not~p.~|~p \in Atoms(b_U(P)) \backslash U \}
	\end{equation}
\end{definition}

$EC_U(P)$为$Atoms(b_U(P)) \backslash U$中的原子引入一组规则：
\begin{equation}
	p~\leftarrow~not~p'.~p'~\leftarrow~not~p.
\end{equation}

其中的$p'$其实代表的就是$\neg p$，上面一组规则在ASP逻辑程序中的含义是$p \lor not~p.$，换句话说即，如果一个ASP逻辑程序只有这两个规则，那么它的回答集就是$\{ \{p\},\{p'\} \}$，实际就是$\neg p$或$p$。接着，通过一个简单的例子来展现$EC_U(P)$的效果。
\begin{example}
	给定逻辑程序$P_1$：
	\begin{eqnarray}
		a~\leftarrow~not~d.	\\
		d~\leftarrow~not~c.	\\
		c~\leftarrow~a.	\\
		a~\leftarrow~c,~d.
	\end{eqnarray}
	令分割集$U=\{a\}$，则有：
	\begin{equation}
		b_U(P_1)~=~\{ a~\leftarrow~not~d.~a~\leftarrow~c,~d. \}
	\end{equation}
	使用$gringo$和$clasp$求解得到$\Gamma (b_U(P_1)) = \{ \{a\}  \}$。而$Atoms(b_U(P_1 )) \backslash U = \{c,d\}$，所以根据定义有：
	\begin{equation}
		EC_U(P_1)~=~\{ d~\leftarrow~not~d'.~d'~\leftarrow~not~d.~c~\leftarrow~not~c'.~c'~\leftarrow~not~c. \}
	\end{equation}
	使用$gringo$和$clasp$求解$b_U(P_1) \cup EC_U(P_1)$，得到：
	\begin{equation}
		\Gamma (b_U(P_1) \cup EC_U(P_1)) = \{ \{ a,c,d \}, \{ a,c,d' \}, \{ a,c',d' \}, \{ c',d \} \}
	\end{equation}
	其中的$c'$和$d'$实质代表$\neg c$和$\neg d$。
\end{example}

因为$head(b_U(P)) \subseteq U$，而且$\Gamma (b_U(P)) \subseteq head(b_U(P))$，所以有$\Gamma (b_U(P)) \subseteq U$。$Atoms(b_U(P)) \backslash U$部分的原子真值则无法由$b_U(P)$确定，因为它们有可能被$P \backslash b_U(P)$中的规则推出。加入$EC_U(P)$使得这些原子的真值的有效可能性被加入到$b_U(P)$的回答集中。当然，这里也不是随意的遍历插入。如$\Gamma (b_U(P) \cup EC_U(P))$中只有$\{ c',d \}$而没有$\{a,c',d\}$，这是因为在$\{c',d \}$为真的情况下，原程序无法推出$a$为真。这就是本文定义$EC_U(P)$而没有直接往$b_U(P)$的回答集中遍历插入剩下原子的可能真值组合的原因。

此外，由于现在$Atoms(b_U(P)) \backslash U \neq \emptyset $且在引入$EC_U(P)$后，新的$bottom$（底部）为$b_U(P) \cup EC_U(P)$，记$bottom$的回答集$X=\Gamma (b_U(P) \cup EC_U(P))$，那么这时就有$X \backslash U \neq \emptyset$。

在$Atoms(b_U(P)) \backslash U \neq \emptyset $ 且$X \backslash U \neq \emptyset$的情况下，定义\ref{e_U_P_X}中的操作$e_U(P,X)$只会去掉有形如$a$或$not a$，其中$a \in U$的文字，即只对$U$中的原子进行操作。而实际上，需要保证$U$以外但在$X$中的原子的真值。所以本文为$top$（顶部）定义一个新的规则集合$ECC_U(P,X)$，以保证$X \backslash U$的原子的真值确定性。
\begin{definition}
	规则集合$ECC_U(P,X)$为$P \backslash b_U(P)$提供$X \backslash U$中原子的真值确定性，具体有：
	% 公式换行，手动地使用 \begin{array}
	\begin{equation}
		\begin{array}{rcl}
			ECC_U(P) = \{ \leftarrow~not~p.~|~p \in Atoms(b_U(P)) \backslash U~and~p \in X \} \\
			\cup \{ \leftarrow~p.~|~p \in Atoms(b_U(P)) \backslash U~and~p \notin X \}
		\end{array}
	\end{equation}
\end{definition}

对于$ECC_U(P,X)$直观上的功能就是保证在$P \backslash b_U(P)$中每个原子$p$，若$p \in X$，则要保证$p$为真，即往逻辑程序中加入$\leftarrow~not~p.$；若$p \notin X$，则保证$p$为假，即往逻辑程序中加入$\leftarrow~p.$。基于这样的分析，本文可以得到以下命题。
\begin{proposition}\label{satisfy_proposition}
	已知$P$是一个正规逻辑程序，$U$是一个原子集。那么一个原子集$S \subseteq Atoms(P)$能满足$P$，当且仅当$S = (X \cup Y) \cap Atoms(P)$，其中的$X$和$Y$分别为：
	\begin{itemize}
		\item $X \models b_U(P) \cup EC_U(P)$
		\item $Y \models e_U(P \backslash b_U(P),X) \cup ECC_U(P,X)$
	\end{itemize}
\end{proposition}

事实上，依据定义$EC_U(P)$和$ECC_U(P,X)$过程中的分析便可以清楚地知道命题\ref{satisfy_proposition}的正确性。接下来，看一个验证命题\ref{satisfy_proposition}的例子。
\begin{example}\label{example_3_2}
	继续使用逻辑程序$P_1$，并令分割集$U=\{a\}$，那么可以计算得到：
	\begin{equation}
		b_U(P_1)~=~\{ a~\leftarrow~not~d.~a~\leftarrow~c,~d. \}
	\end{equation}
	及：
	\begin{equation}
		EC_U(P_1)~=~\{ d~\leftarrow~not~d'.~d'~\leftarrow~not~d.~c~\leftarrow~not~c'.~c'~\leftarrow~not~c. \}
	\end{equation}
	且求解得到：
	\begin{equation}
		\Gamma (b_U(P_1) \cup EC_U(P_1)) = \{ \{ a,c,d \}, \{ a,c,d' \}, \{ a,c',d' \}, \{ c',d \} \}
	\end{equation}
	令$X=\{a,c,d'\}$，显然，$X \models b_U(P_1 ) \cup EC_U(P_1)$。另，根据定义，可以计算得：
	\begin{equation}
		\begin{array}{rcl}
			e_U(P_1 \backslash b_U(P_1), X) = \{ d~\leftarrow~not~c.~c~\leftarrow. \}	\\
			ECC_U(P_1, X) = \{ \leftarrow~not~c.~\leftarrow~d. \}
		\end{array}
	\end{equation}
	并求解得到：
	\begin{equation}
		\Gamma (e_U(P_1 \backslash b_U(P_1), X)) = \{ \{ c \} \}
	\end{equation}
	令$Y=\{c\}$，显然，$Y \models e_U(P_1 \backslash b_U(P_1 ),X) \cup  ECC_U(P_1,X)$。$X \cup Y = \{a,c,d'\}$，明显也有$X \cup Y \models P_1$。
\end{example}

在引入了$EC_U(P)$和$ECC_U(P,X)$后，依据命题\ref{satisfy_proposition}，可以知道原程序的模型可以通过$bottom$和$top$两部分的模型计算得到。接下来，本文引入逻辑程序中的环与环公式的概念，来定义可以用于求解原程序的$top$部分。首先，这里定义两个结构性的规则集合。
\begin{definition}\label{in_out}
	对一个逻辑程序$P$基于一个原子集$U$，定义以下两个规则集合：
	\begin{eqnarray}
		in_U(P) = \{ r \in P~|~head(r) \cap U \neg \emptyset~and~(body^+(r) \cup head(r)) \subseteq U \}	\\
		out_U(P) = \{ head(r) \subseteq U~and~(body^+(r) \cup head(r)) \cap U \neq \emptyset \}
	\end{eqnarray}
\end{definition}

$in_U(P)$和$out_U(P)$是与逻辑程序正依赖图结构性相关的规则集合。在正规逻辑程序中直观的含义是，$in_U(P)$代表了头部属于分割集$U$，而体部正原子存在与$U$中原子不同的原子；$out_U(P)$代表了头部不属于分割集$U$，而体部正原子存在与$U$中原子相同的原子。根据两者的定义，显然可以得到：
\begin{eqnarray}
	in_U(P) \subseteq b_U(P)	\\
	out_U(P) \subseteq P \backslash b_U(P)
\end{eqnarray}

在有了$in_U(P)$和$out_U(P)$的概念后，本文开始使用逻辑程序中环和环公式的思想。
\begin{definition}[半环]\label{semi_loop}
	一个非空原子集$E$称为逻辑程序$P$基于原子集$U$的半环（$smei-loop$），当且仅当在$P$中存在一个环$L$使得$E = L \cap U$且$E \subset L$。
\end{definition}
\begin{definition}\label{SLUP}
	已知正规逻辑程序$P$和原子集$X$、$U$，且$E$为$P$基于$U$的半环，定义一个半环集合如下：
	\begin{equation}
		SL_U(P,X) = \{ E~|~E \subseteq X~and~R^-(E,P,X) \subseteq in_U(P) \}
	\end{equation}
\end{definition}

直观来说，一个半环$E$属于$SL_U(P,X)$当且仅当在$P$中存在一个环$L$满足$E \subset L$且$X \nvDash LF(L,P)$。定义$SL_U(P,X)$这样一个半环集合的主要作用是联合定理\ref{Lin_Zhao_loop_theorem}，即Lin和Zhao在2004年提出来的环公式理论，来定义新的$top$。

在有了上述一系列的预备概念后，本文现在给出新的程序分割方法中的$top$的定义。
\begin{definition}\label{new_top}
	给定$P$为一个正规逻辑程序，$X$和$U$为原子集，$P$基于$U$通过$X$得到的$top$记为$t_U(P,X)$，其由以下三部分组成：
	\begin{itemize}
		\item $P \backslash (b_U(P) \cup out_U(P)$，
		\item $\{ x_E~\leftarrow~body(r)~|~r \in in_U(P)~and~r \in R^-(E,P,X) \},~for~each~E \in SL_U(P,X)$，
		\item $\{ head(r)~\leftarrow~x_{E_1},x_{E_2},...,x_{E_t},body(r)~|~r \in out_U(P),~for~all~possible~E_i \in SL_U(P,X)(1 \leq i \leq t)~s.t.~body^+(r) \cap E_i \neq \emptyset \}$。
	\end{itemize}
\end{definition}

其中$x_{E_i}$为基于$SL_U(P,X)$中的$smei-loop$引入的新原子，对于这些新原子，最后通过逻辑交$Atoms(P)$即可消去。在明确了新的$top$后，本文将对定义\ref{asp_solution}的重定义，给出新的逻辑程序$P$基于原子集$U$的方案（$Solution$）。
\begin{definition}\label{new_solution}
	给定正规逻辑程序$P$和原子集$U$，$P$基于$U$的方案（$Solution$）是一组原子集$\langle X,Y \rangle$，其中：	
	\begin{itemize}
		\item $X$是$b_U(P) \cup EC_U(P)$的一个回答集；
		\item $Y$是$e_U(t_U(P,X),X) \cup ECC_U(P,X)$的一个回答集。
	\end{itemize}
\end{definition}

下面给出一个计算逻辑程序$P$基于原子集$U$的方法的例子。
\begin{example}
	继续使用逻辑程序$P_1$，并令分割集$U=\{a\}$，根据定义\ref{in_out}可以计算得到：
	\begin{eqnarray}
		in_U(P_1) = \{ a~\leftarrow~c,~d. \}	\\
		out_U(P_1) = \{ c~\leftarrow~a. \}
	\end{eqnarray}
	
	且可以从$P_1$中取环$L=\{a,c\}$，则有$E = L \cap U = \{a\}$，满足$E \subset L$。并由例\ref{example_3_2}已经算得：
	\begin{equation}
		\Gamma (b_U(P_1) \cup EC_U(P_1)) = \{ \{ a,c,d \}, \{ a,c,d' \}, \{ a,c',d' \}, \{ c',d \} \}
	\end{equation}
	
	这里，取$X = \{a,c,d'\}$和$X' = \{a,c,d\}$，那么可以计算得到：
	\begin{eqnarray}
		R^-(E,P_1,X) = \{ a~\leftarrow~not~d. \}	\\
		R^-(E,P_1,X') = \{ a~\leftarrow~c,~d. \}
	\end{eqnarray}
	
	则有：
	\begin{eqnarray}
		SL_U(P_1,X) = \emptyset	\\
		SL_U(P_1,X') = \{ \{a\} \}
	\end{eqnarray}
	
	并基于定义\ref{new_top}计算得到：
	\begin{eqnarray}
		t_U(P_1,X) = \{ d~\leftarrow~not~c.~c~\leftarrow~a. \}	\\
		t_U(P_1,X') = \{ d~\leftarrow~not~c.~x_{\{a\}}~\leftarrow~c,~d.~c~\leftarrow~x_{\{a\}},~a. \}
	\end{eqnarray}
	
	另外，有：
	\begin{eqnarray}
		ECC_U(P_1,X) = \{ \leftarrow~not~c.~\leftarrow~d. \}	\\
		ECC_U(P_1,X') = \{ \leftarrow~not~c.~\leftarrow~not~d. \}
	\end{eqnarray}
	
	通过求解器计算得到：
	\begin{eqnarray}
		\Gamma (e_U(t_U(P_1,X),X) \cup ECC_U(P_1,X)) = \{ \{c\} \}	\\
		\Gamma (e_U(t_U(P_1,X'),X') \cup ECC_U(P_1,X')) = \emptyset
	\end{eqnarray}
	
	其中$\langle X,\{c\} \rangle$为$P$基于$U$的一个方案。
\end{example}

在有了新的方案的定义后，本文提出一个引理，具体如下：
\begin{lemma}\label{lemma_3_1}
	对任意的正规逻辑程序$P$和原子集$U$，如果$\langle X,Y \rangle$是$P$基于$U$的一组方案，且$SL_U(P,X) = \emptyset$，那么$(X \cup Y) \cap Atoms(P)$是逻辑程序$P$的一个回答集。
\end{lemma}

\begin{proof}
	根据前面已提及的$SL_U(P,X)$的属性，如果一个$smei-loop~E$属于$SL_U(P,X)$，则表示存在一个环$L$，有$E \subset L$，且$X \nvDash LF(L,P)$。所以在$SL_U(P,X) = \emptyset$时，可以得到：在逻辑程序$P$中不存在环$L$满足以下三点：
	\begin{itemize}
		\item $L \cap U = \emptyset$，
		\item $L \cap (Atoms(P) \backslash U) \neq \emptyset$，
		\item $X \cup Y \nvDash LF(L,P)$。
	\end{itemize}
	
	所以可以进一步得到$(X \cup Y) \cap Atoms(P)$满足$P$中的所有环公式。而命题\ref{satisfy_proposition}中指出$(X \cup Y) \cap Atoms(P)$是$P$的模型，联合Lin和Zhao的环理论，即定理\ref{Lin_Zhao_loop_theorem}，可以知道$P$的模型若能满足其所有环公式，则是$P$的一个回答集，所以可以得到$S = (X \cup Y) \cap Atoms(P)$是$P$的一个回答集。\quad
\end{proof}

更进一步地，本文依据新的程序分割方法，提出新的分割理论。
\begin{theorem}[新分割理论]\label{new_splitting_theorem}
	已知正规逻辑程序$P$和原子集$U$，一个原子集$S$是$P$的回答集，当且仅当$S = (X \cup Y) \cap Atoms(P)$，其中$\langle X,Y \rangle$是$P$基于$U$的某组方案。
\end{theorem}

在定理\ref{new_splitting_theorem}中给出的新分割理论实质上是跟Lifschitz和Turner当初提出的分割理论是一样的。本质上的不同在于定义来计算$P$基于$U$的方案$\langle X,Y \rangle$的运算符的不同。

$SL_U(P,X)$根据Lin和Zhao的环理论，定义的让底部回答集$X$所不能满足的环公式的环与分割集的交集所构成的半环。定义这些半环的目的就是为了依据它们构造出能保证$X$为真的规则。然而，更进一步地，基于Ji和Wan等在环理论的基础下提取出特征环（$Proper~Loop$）的思想下，可以想象得到并非所有的半环都是必要的，本文在此根据Ji和Wan等的思想，提取出必要的半环，定义一个$SL_U(P,X)$的子集以指代必须的半环集合。
\begin{definition}[关键半环（$Dominated~Semi-loop$）]\label{dominated_semi_loop}
	给定正规逻辑程序$P$和原子集$U$，一个半环$E$被称为关键半环，当且仅当存在另一个半环$E'$满足$E' \subseteq E$，且有$E' \cap head(in_U(P)) = E \cap head(in_U(P))$，以及$E' \cap body^+(out_U(P)) = E \cap body^+(out_U(P))$，同时称$E$能代表$E'$。
\end{definition}

根据关键半环的特性，因为关键半环能涵盖其所代表的半环的头部和体部正原子，所以关键半环的环公式可以推出其所能代表的半环的环公式。由于关键半环能够代替其他半环，所以这里定义一个关键半环的集合。
\begin{definition}[关键半环集]\label{DSL_U_PX}
	给定析取逻辑程序$P$和原子集$U$，$P$关于$U$的关键半环集记为$DSL_U(P,X)$，并定义为以下集合：
	\begin{equation}
		\begin{array}{rcl}
			DSL_U(P,X) = \{ E~|~E \in SL_U(P,X)~and~there~dose~not~\\
			exist~another~E' \in SL_U(P,X)~s.t.~E~is~dominated~by~E'\}
		\end{array}
	\end{equation}		
\end{definition}

本文在此提供一个计算$DSL_U(P,X)$的算法$Algorithm$\ref{DSLUPX}，具体如下：

% 插入算法
\RestyleAlgo{ruled}\LinesNumbered\input{algorithm/DSLUPX.tex}

基于$DSL_U(P,X)$，本文定义关键顶部（$Dominated~Top$）和关键方案（$Dominated~Solution$），它们的具体内容就是通过把其中用到的$SL_U(P,X)$替换为$DSL_U(P,X)$，并记关键顶部为$dt_U(P,X)$。最后本节扩展新的分割集理论，得到以下定理。
\begin{theorem}\label{new_d_splitting_theorem}
	给定一个正规逻辑程序$P$和原子集$U$，一个原子集$S$是$P$的一个回答集，当且仅当$S = (X \cup Y) \cap Atoms(P)$，其中$\langle X,Y \rangle$是$P$基于$U$的某组关键方案。
\end{theorem}

对于$bottom$部分，通过新定义$EC_U(P)$来补充$Atoms(b_U(P)) \backslash U$中原子真值的可能性，以保证这部分原子不会被忽略。

对于$top$部分，定义了$ECC_U(P,X)$来在$top$中确保$bottom$部分的回答集中的原子必为真。同时使用环理论，引入$smei-loop$的集合$SL_U(P,X)$，其代表的是环公式不能被底部回答集所满足的环所相关的$smei-loop$集合。基于$SL_U(P,X)$和原来的$P \backslash b_U(P)$来构建出新的$top$，即定义\ref{new_top}中的$t_U(P,X)$。

在上述的定义和分析证明过程中可以明确地知道新的程序分割方法能对任意原子集构成的分割集都有效。

在给出了正规逻辑程序的新程序分割方法后，下一节中将新的程序分割方法扩展到析取逻辑程序中。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{析取逻辑程序分割方法}

本小节将把新的程序分割方法从正规逻辑程序扩展到析取逻辑程序。由于之前所定义下的规则集合都是基于普遍规则所定义的，只是在分析证明时用了正规逻辑程序的性质，所以对于析取逻辑程序，这些规则集合的操作符依旧有用。

具体地，$b_U(P)$，$e_U(P,X)$，$EC_U(P)$，$ECC_U(P,X)$，$in_U(P)$，$out_U(P)$，$SL_U(P,X)$和$DSL_U(P,X)$都保持原来的定义不变。跟正规逻辑程序有所不同的是，在析取逻辑程序中，$in_U(P) \cap out_U(P) \neq \emptyset$。
在明确了需要用到的基本概念后，本文将重新定义析取逻辑程序的$top$部分，依旧标记为$t_U(P,X)$。

\begin{definition}[析取逻辑程序的$top$]\label{dlp_top}
	给定一个析取逻辑程序$P$和原子集$X$，$U$，$P$基于$U$关于$X$的$top$记为$t_U(P,X)$，并由以下三部分组成：
	\begin{itemize}
		\item $P \backslash (b_U(P) \cup out_U(P)$，
		\item $\{ \{x_E\} \cup head(r) \backslash E~\leftarrow~body(r)~|~r \in in_U(P)~and~r \in R^-(E,P,X) \},~for~each~E \in SL_U(P,X)$，
		\item $\{ head(r)~\leftarrow~x_{E_1},x_{E_2},...,x_{E_t},body(r)~|~r \in out_U(P),~for~all~possible~E_i \in SL_U(P,X)(1 \leq i \leq t)~s.t.~body^+(r) \cap E_i \neq \emptyset \}$。
	\end{itemize}
\end{definition}

这里给出如此定义析取逻辑程序的$t_U(P,X)$的有效性的证明。

在证明析取逻辑程序的$top$的有效性后，关于一个析取逻辑程序$P$基于一个原子集$U$的方案定义依旧，只是相应的$t_U(P,X)$修改为定义\ref{new_top}中的。同时，基于上述的分析和证明，本文给出关于析取逻辑程序在程序分割理论下的回答集定理。
\begin{theorem}\label{dlp_splitting_theorem}
	给定析取逻辑程序$P$和原子集$U$，一个原子集$S$是$P$的一个回答集，当且仅当$S = (X \cup Y) \cap Atoms(P)$，其中$\langle X,Y \rangle$是$P$基于$U$的某组方案。
\end{theorem}

联合析取逻辑程序的$t_U(P,X)$的有效性的证明和3.2.1中关于定理\ref{new_splitting_theorem}的证明可以直接地得到定理\ref{dlp_splitting_theorem}的正确性。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{强程序分割方法}

在Lifschitz和Turner的分割理论中，分割集U把逻辑程序$P$分割为$b_U(P)$和$P \backslash b_U(P)$两部分，原逻辑程序的回答集可以通过这两部分的回答集来求解得到。除了这个直接面对回答集求解的特性之外，Lifschitz和Turner的分割理论还能引申出来其他的特性。对此，本文总结出如下命题。
\begin{proposition}\label{proposition_3_2}
	给定逻辑程序$P$，原子集$U$是$P$在Lifschitz和Turner的分割理论定义下的分割集。另有逻辑程序$P'$满足$Atoms(P') \cap U = \emptyset$则原子集$S$是逻辑程序$P \cup P'$的一个回答集，当且仅当$S = X \cup Y$，其中$X$为$b_U(P)$的某个回答集，$Y$为$e_U(P \backslash b_U(P),X) \cup P'$的某个回答集。
\end{proposition}

\begin{proof}
	由于$Atoms(P') \cap U = \emptyset$，且$\Gamma (b_U(P)) \subseteq U$，所以$\Gamma (P') \cap \Gamma (b_U(P)) = \emptyset$，同时有$\Gamma (P') \cap U = \emptyset$。所以$P \cup P'$中划分出的$b_U(P)$依旧具有命题封闭性，其回答集依旧不受$(P \cup P') \backslash b_U(P)$影响。
	
	又在$Atoms(P') \cap U = \emptyset$及$Atoms(b_U(P)) \subseteq U$情况下，可以得到：	
	\begin{equation}
		(p \cup P') \backslash b_U(P) \equiv (P \backslash b_U(P)) \cup P'
	\end{equation}
	
	而$e_U(P,X)$操作中只会依旧条件删去与$U$有关的文字以保证$X$中的原子的真值确定性。所以在$Atoms(P') \cap U = \emptyset$情况下，$e_U(P,X)$不需要对$P'$操作，而$P'$所能推出的结论也不会干扰$P \backslash b_U(P)$或受其干扰，所以$e_U(P \backslash b_U(P),X) \cup P'$可以求解出$P \cup P'$的另一部分回答集。
	
	综上所述，可以得到命题\ref{proposition_3_2}的正确性。\quad
\end{proof}

然而，对于本文所关注和扩展的使用任意原子集作为分割集时，命题\ref{proposition_3_2}并不成立。但基于这个思想，为了继续扩展分割集理论对逻辑程序的结合律有效，本文提出了强程序分割方法（$Strong~Splitting~Method$）。为此，本文对$SL_U(P,X)$进行了扩展。
\begin{definition}\label{SS_U_PX}
	给定析取逻辑程序$P$以及原子集$X$和$U$，标记以下原子集的集合：
	\begin{equation}
		SS_U(P,X)~=~\{ E~|~E~is~an~nonempty~subset~of~U,~E \subseteq X~and~R^-(E,P,X) \subseteq in_U(P) \}
	\end{equation}
\end{definition}

很直观地，$SS_U(P,X)$把$SL_U(P,X)$从$P$关于$U$的$smei-loop$扩展到$U$的任意非空子集。同时，对任何满足$Atoms(P') \cap U = \emptyset$的析取逻辑程序$P'$，可以得到$b_U(P \cup P') = b_U(P)$，且对任意的原子集$X$有$SL_U(P \cup P',X) \subseteq SS_U(P,X)$。此外，若$U$是Lifschitz和Turner的分割理论定义下的分割集，则对任意原子集$X$都有$SS_U(P,X) = \emptyset$。基于$SS_U(P,X)$，本文提出了析取逻辑程序$P$基于原子集$U$关于原子集$X$的强顶部（$Strong~Top$）。
\begin{definition}[强顶部（$Strong~Top$）]\label{strong_top}
	给定析取逻辑程序$P$以及原子集$X$和$U$，记$P$基于$U$关于$X$的强顶部（$Strong~Top$）为$st_U(P,X)$，其由以下三部分组成：
	\begin{itemize}
		\item $P \backslash (b_U(P) \cup out_U(P)$，
		\item $\{ \{x_E\} \cup head(r) \backslash E~\leftarrow~body(r)~|~r \in in_U(P)~and~r \in R^-(E,P,X) \},~for~each~E \in SS_U(P,X)$，
		\item $\{ head(r)~\leftarrow~x_{E_1},x_{E_2},...,x_{E_t},body(r)~|~r \in out_U(P),~for~all~possible~E_i \in SS_U(P,X)(1 \leq i \leq t)~s.t.~body^+(r) \cap E_i \neq \emptyset \}$。
	\end{itemize}
\end{definition}

在给出$st_U(P,X)$后，本文定义一个析取逻辑程序$P$关于原子集$U$的强方案（$Strong~Solution$）。
\begin{definition}[强方案（$Strong~Solution$）]\label{strong_solution}
	给定析取逻辑程序$P$和原子集$U$，$P$关于$U$的强方案为一个原子集组合$\langle X,Y \rangle$，其中$X$和$Y$满足：
	\begin{itemize}
		\item $X$是$b_U(P) \cup EC_U(P)$的一个回答集；
		\item $Y$是$e_U(st_U(P,X),X) \cup ECC_U(P,X)$的一个回答集。
	\end{itemize}
\end{definition}

在有了强方案的定义后，依据$SS_U(P,X)$对$SL_U(P,X)$性质的扩展，可以得到以下两个定理。








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{计算复杂性分析}

在上一节中，本文详细地给出了正规逻辑程序和析取逻辑程序的新程序分割方法，并证明了新的程序分割方法对任意原子集构成的分割集都有效。当真正的自由是规矩。任意原子集给了程序分割很大的自由度，但这更多是理论层面的。本节将分析讨论分割集如何影响着程序分割过程的计算复杂性，并指出怎样的原子集作为分割集才会让程序分割更高效。此外，由于析取逻辑程序跟正规逻辑程序的本质区别在于头部的基，即头部中原子的数量。所以本节以正规逻辑程序在程序分割方法上的计算复杂性为例进行分析。



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{底部计算复杂性}

本小节主要对问题i进行分析。底部中的$EC_U(P)$是为了补充$Atoms(b_U(P)) \backslash U$中的原子在回答集中的真值可能性而定义的。对于$EC_U(P)$带来的耗时，本节给出以下两个降低计算复杂性的方法：




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{顶部计算复杂性}
本小节主要对问题ii进行分析。关于顶部中$DSL_U(P,X)$所带来的复杂性，依据其定义可以知道其中的关键半环$E$与其所能代表的半环$E'$必须满足：




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{本章小结}

本章给出了Lifschitz和Turner的分割集理论的证明，并提出了在正规逻辑程序中对任意原子集作为分割集都有效的新程序分割方法，并把这个方法推广到析取逻辑程序。此外，在分析程序分割方法的计算复杂性时，引申出通过程序结论来扩展新分割理论的应用场景，这个应用场景将紧接着在下一章描述。


