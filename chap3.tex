\chapter{新分割集与程序分割}

本章基于对Lifschitz和Turner提出的分割集和程序分割理论的分析，提出了新的分割集和程序分割方法。实际上是提出了一个可以对任意原子集作为分割集都有效的程序分割方法。本章将分别给出正规逻辑程序和析取逻辑程序的新程序分割方法，然后提出一个强程序分割方法。最后以正规逻辑程序的程序分割方法为例，对新的程序分割方法的计算复杂性进行分析，并指出主要性能瓶颈所在及改进思路。


\section{新分割集}

在给出新分割集之前，本文将对Lifschitz和Turner提出的分割集理论进行分析，然后基于他们对分割集的定义提出一个计算分割集的算法，并对ASP竞赛中的程序进行计算，对计算结果进行分析，随后给出本文定义的新分割集。

\begin{definition}\label{hh_dh}
	hhh
\end{definition}

\subsection{原有分割集和程序分割的分析证明}

Lifschitz和Turner给出的分割集定义是：一个原子集$U$称为一个逻辑程序$P$的分割集，当且仅当对$P$中的所有规则$r$都有$head(r) \cap U \neq \emptyset$蕴涵$Atoms(r) \subseteq U$。这个分割集定义的直观含义就是一个分割集若包含规则头部的原子，则也可以包含该规则的所有原子。这样的性质保证了分割集$U$可以把原程序从结构上划分成两部分，进而保证了原程序的回答集可以从分割后的两部分的回答集求解得到。Lifschitz和Turner在1994年的原文中只给出了程序分割方法的定义，即根据定义(\ref{asp_solution})分别求出底部$b_U(P)$和化简后的顶部$e_U(t_U(P),X)$的回答集$X$和$Y$，根据方案$\langle X,Y \langle$得到原程序的回答集。本文在这里补充给出这种分割方法的可行性证明。关于Lifschitz和Turner的程序分割方法可行性的证明如下。



\begin{proof}
首先证明分割集可以把逻辑程序划分为回答集互斥的两部分，并且底部的回答集是原逻辑程序回答集子集。

根据定义\ref{splitting_set}，分割集$U$满足对于逻辑程序$P$中任意的规则$r$都有，$head(r) \cap U \neq \emptyset$蕴涵$Atoms(r) \subseteq U$。而根据定义\ref{bottom_top}有：	
\begin{eqnarray}
	b_U(P) = \{ r \in P~|~head(r) \cap U \neq \emptyset \}	\\
	t_U(P) = P~\backslash~b_U(P)
\end{eqnarray}

根据分割集$U$的特性，可以知道：$Atoms(b_U(P)) \subseteq U$，并定义：
\begin{eqnarray}
	head(t_U(P))~=~\bigcup_{r \in t_U(P)} head(r)	\\
	body(t_U(P))~=~\bigcup_{r \in t_U(P)} body(r)
\end{eqnarray}

另，记一个逻辑程序$P$的回答集为$\Gamma (P)$，而回答集必是一个逻辑程序的头部原子的子集，即$\Gamma (P) \subseteq head(P)$。根据$t_U(P)$的定义可以知道：	
\begin{eqnarray}
	head(t_U(P)) \subseteq Atoms(P) \backslash U \\
	\Gamma (b_U(P)) \subseteq U
\end{eqnarray}
由于$head(t_U(P)) \cap U = \emptyset$，所以$\Gamma (t_U(P)) \cap U = \emptyset$，故有$\Gamma (b_U(P)) \cap \Gamma (t_U(P)) = \emptyset$，这样保证了$b_U(P)$和$t_U(P)$的回答集是互斥的。此外，我们已知：	
\begin{eqnarray}
	Atoms(b_U(P)) \subseteq U \\
	head(t_U(P)) \subseteq Atoms(P) \backslash U \\
	head(b_U(P)) \cap head(t_U(P)) = \emptyset
\end{eqnarray}

这些关系表明$b_U(P)$于原逻辑程序而言，是一个独立的模块，其回答集只能从$b_U(P)$这部分推出，因为$head(b_U(P))$中的原子不会出现在$head(t_U(P))$中，即$\Gamma (b_U(P))$中的元素不需要依赖$t_U(P)$中的规则，一旦$head(b_U(P))$中的某个元素被推出为真，那么放在整个程序它都将是真的，即它必为原程序回答集的元素，即$\Gamma (b_U(P))$中的元素必将出现在原程序的某个回答集中。

然而，并不是直接计算$b_U(P)$和$t_U(P)$的回答集就可以得到最终的回答集。因为$body(t_U(P))$中可能会包含有$U$中的原子，而如果这些原子是在$\Gamma (b_U(P))$中的话，我们是可以知道其真值的，因为$\Gamma (b_U(P))$必是原程序回答集的一部分。那么需要定义一个操作来删除这些可以肯定真值的原子。这个操作就是定义\ref{e_U_P_X}中的$e_U(P,X)$。

接着证明$e_U(P,X)$的有效性。

令$X = \Gamma (b_U(P))$。对于$X$中的原子，其在$t_U(P)$中的形式只有正文字和负文字，即$x$或$not~x$，$x \in X$。

在$e_U(P,X)$的定义中，它只保留满足以下条件的规则$r$：$body^+(r) \cap U \subseteq X$，及$(body^-(r) \cap U) \cap X = \emptyset$。并在保留下来的规则中删去所有形如$a$或$not~a$，其中$a \in U$的文字。	
\begin{enumerate}
	\item 对于满足$body^+(r) \cap U \subseteq X$的规则$r$，后续的化简操作是$body^+(r) \backslash U$，而$X \subseteq U$，且$body^+(r) \cap U \subseteq X$，所以实质的意义就是$body^+(r) \backslash X$。对于$x \in body^+(r) \cap X$，因为$x \in X$，$X = \Gamma (b_U(P))$，并且$X$必为原程序回答集的一部分，所以$x$也为原逻辑程序中某个回答集的元素，所以可以确定$x$为真，且体部为合取关系，根据$head(t_U(P)) \subseteq Atoms(P) \backslash U$，即$x$在$t_U(P)$中不会在出现在规则的头部，即在$t_U(P)$中不可能推出$x$为真，但从$X$可以确定其为真，故需要删去$x$。所以保留满足$body^+(r) \cap U \subseteq U$的规则$r$，并执行$body^+(r) \backslash U$操作。
	\item 对于满足$(body^-(r) \cap U) \cap X= \emptyset$的规则$r$，后续的化简操作是$body^-(r) \backslash U$。反向考虑，如果$(body^-(r) \cap U) \cap X \neq \emptyset$，即规则$r$的体部中包含$not~a$，$a \in X$。而从上面的说明可以知道$a \in X$，则可以判定$a$为真，即$not~a$为假（因为“推不出$a$为真”为假）。而体部为合取关系，一旦确定体部中有为假的元素，则体部为假，该规则无法推出头部为真，所以可以删去该规则，故只考虑满足$(body^-(r) \cap U) \cap X = \emptyset$的规则。此外，对于满足这个条件的规则，其$body^-(r) \cap X = \emptyset$，而对于$body^-(r)$可能存在$U \backslash X$中的元素，$U \backslash X$中的元素直接含义就是原程序回答集中推不出为真的原子，所以若$b \in U \backslash X$，则$not~b$为真。跟1中一样，体部为真的元素应该直接删去。所以保留满足$(body^-(r) \cap U) \cap X = \emptyset$的规则$r$，并执行$body^-(r) \backslash U$的操作。
\end{enumerate}	

根据上面的证明可以知道，$X$作为原程序回答集的一部分，$e_U(t_U(P),X)$利用$X$中元素的真值化简出一个计算原程序剩下回答集部分的逻辑程序。记$Y = \Gamma (e_U(t_U(P),X))$。
	
$b_U(P)$中只包含$U$中的原子，它自身是一个命题闭包，所以求解得到的回答集$X$必是原程序回答集的部分。而$e_U(t_U(P),X)$得到一个跟$U$无关的程序，同时确保了$X$中的元素为真，所以这部分求解得到的回答集$Y$就是原程序回答集剩下的部分。且有	
\begin{eqnarray}
	X \subseteq Atoms(P) \cap U	\\
	Y \subseteq Atoms(P) \backslash U
\end{eqnarray}	
	
所以$X \cap Y = \emptyset$，故$X \cup Y$是确保一致的，并且为原程序的回答集。\quad
\end{proof}


上述证明过程说明了Lifschitz和Turner提出的程序分割方法的有效性。由于$U$是一个命题闭包，它能有效地把一个逻辑程序的规则根据自己的闭包性在结构上一分为二。



\subsection{提出新的分割集}

Lifschitz和Turner给出的分割集的定义实际上是一个验证型定义。他们定义一个原子集$U$是逻辑程序$P$的分割集，当且仅当$P$中的每个规则$r$满足$head(r) \cap U \neq \emptyset$蕴涵$Atoms(r) \subseteq U$。这个定义从直观上来说就是如果一个原子集合是一个逻辑程序的分割集，那么它满足逻辑程序中凡是头部与其有交集的规则，都会有该规则的所有原子都在该原子集合内。本文根据Lifschitz和Turner对分割集的定义给出了一个计算逻辑程序的分割集的算法，为$Algorithm 1$。







\section{新程序分割方法}

本小节讲解优先级限定的翻译，优先级限定可以等价于并行限定公式(\ref{form_pri2par})，可以将定义\ref{def_parallelcirc2sm}推广到优先级限定的情况下，因此，有如下优先级限定到稳定模型语义下的翻译。

\begin{definition}\label{def_prioritycirc2sm}
设$\varphi$为任意具有否定范式形式的一阶语句，$\sigma^1,...,\sigma^k$和$\sigma_v$表示k+1个谓词常元集合，定义
$Tr^p_{v}(\varphi;\sigma^1>...>\sigma^k;\sigma_v)$ 为如下公式的合取：
\begin{eqnarray}
% \nonumber to remove numbering (before each equation)
  \varphi^{\neg\neg}~\wedge~\bigwedge_{1\leq j \leq k}\widetilde{\varphi_j} \\
  \bigwedge_{1\leq j \leq k}(\Gamma_j~\leftrightarrow~\bigwedge_{P \in \sigma_i}~ \forall \overline{x} (P(\overline{x})~\vee~P(\overline{x}))) \\
  \bigwedge_{1\leq j \leq k}~ \forall \overline{x} (\Gamma_j~\rightarrow~\bigwedge_{Q \in \delta_j}Q(\overline{x}))
\end{eqnarray}
其中：
\begin{enumerate}
  \item $\varphi^{\neg\neg}$是将$\varphi$中所有形如$P(\overline{x})$($P$在$\sigma^j$,$1 \leq j \leq k$, 的并集中)的公式替换为$\neg\neg P(\overline{x})$后所得到的公式；
  \item $\widetilde{\varphi_j}$是将$\varphi$进行如下替换：(i)将所有形如$(P(\overline{x})\rightarrow\Gamma_j)(P~\in~\sigma^j)$ 的公式替换为负文字$\neg P(\overline{x})$；(ii)将所有形如$P(\overline{x})(P \in \bigcup_{1 \leq m < j \sigma^m})$的公式替换成$\neg\neg P(\overline{x})$；(iii)将正文字$Q(\overline{x})(Q \in \bigcup_{j < n \leq k}\sigma^n \cup \sigma_v)$替换为$Q'(\overline{x})$，将形如$(Q'(\overline{x})\\\rightarrow \Gamma_j)$ 的公式替换为负文字$\neg Q'(\overline{x})$；$\delta_j$表示$Q^j$的并集。
\end{enumerate}
\end{definition}

\begin{proposition}\label{pro_prioritycirc2sm}
设$\varphi$为具有否定范式形式的任意一阶语句，$\sigma^1,...,\sigma^k$和$\sigma_v$是k+1个谓词常元集合，则$\exists \delta \mathbf{SM}[Tr^p_v(\varphi;\sigma^1>...>\sigma^k;\sigma_v);\bigcup_{1 \leq j \leq k \sigma^j \cup \delta}]$等价于$\mathbf{CIRC}[\varphi;\sigma^1>...>\sigma^k;\sigma_v]$，其中$\delta$是辅助谓词常元集合。
\end{proposition}

通过下面一个例子介绍优先级翻译的主要步骤。
\begin{example}\label{emp_pri}
对于优先级限定$\mathbf{CIRC}[\theta;P_1>P_2>P_3;Z]$的计算，首先将公式进行如下转换：
\begin{enumerate}
  \item $\theta$转成经典一阶逻辑下NNF和CNF的形式；
  \item $\theta^{\neg\neg}\Leftrightarrow\theta(P_1\Rightarrow\neg\neg P_1,P_2\Rightarrow\neg\neg P_2,P_3\Rightarrow\neg\neg P_3)$；
  \item $\tilde{\theta_1}\Leftrightarrow\theta(P_2\Rightarrow Q^{1}_{P_2},P_3\Rightarrow Q^{1}_{3},Z\Rightarrow Q_Z^{1},\neg P_2\Rightarrow (Q^{1}_{2}\rightarrow\Gamma_1),\neg P_3\Rightarrow (Q^{1}_{P_3} \rightarrow\Gamma_1),\neg Z\Rightarrow(Q^{1}_{Z}\rightarrow\Gamma_1))$；
  \item $\tilde{\theta_2}\Leftrightarrow\theta(P_1\Rightarrow \neg\neg P_1,P_3\Rightarrow Q^{2}_{P_3},Z\Rightarrow Q_Z^{2},\neg P_3\Rightarrow (Q^{2}_{P_3} \rightarrow\Gamma_2),\neg Z\Rightarrow(Q^{2}_{Z}\rightarrow\Gamma_2))$；
  \item $\tilde{\theta_3}\Leftrightarrow\theta(P_1\Rightarrow \neg\neg P_1,P_2\Rightarrow \neg\neg P_2,Z\Rightarrow Q_Z^{P_3},\neg Z\Rightarrow(Q^{3}_{Z}\rightarrow\Gamma_3))$。
  \item $\phi_1~\Leftrightarrow~(\Gamma_1~\rightarrow~(P_1(x)~\vee~\neg P_1(x)))
      \wedge~Tr_{QE}(\exists x((P_1(x)~\vee~\neg P_1(x)))~\rightarrow~\Gamma_1))\\
      \wedge~(\Gamma_1~\rightarrow~Q^1_Z)~\wedge~(\Gamma_1~\rightarrow~Q^1_{P_2})
      ~\wedge~(\Gamma_1~\rightarrow~Q^1_{P_3})$
  \item $\phi_2~\Leftrightarrow~(\Gamma_2~\rightarrow~(P_2(x)~\vee~\neg P_2(x)))
      \wedge~Tr_{QE}(\exists x((P_2(x)~\vee~\neg P_2(x)))~\rightarrow~\Gamma_2))\\
      \wedge~(\Gamma_2~\rightarrow~Q^2_Z)~\wedge~(\Gamma_2~\rightarrow~Q^2_{P_3})
      $
  \item $\phi_3~\Leftrightarrow~(\Gamma_3~\rightarrow~(P_3(x)~\vee~\neg P_3(x)))
      \wedge~Tr_{QE}(\exists x((P_3(x)~\vee~\neg P_3(x)))~\rightarrow~\Gamma_3))\\
      \wedge~(\Gamma_1~\rightarrow~Q^3_Z))$
\end{enumerate}
其中$\alpha\Rightarrow\beta$的意义是将公式$\theta$ 中的$\alpha$替换成$\beta$，设$\psi$为公式$\theta^{\neg\neg}~\wedge~\tilde{\theta_1}~\wedge~\tilde{\theta_2}~\wedge~\tilde{\theta_3}
~\wedge~\phi_1~\wedge~\phi_2~\wedge~\phi_3$，则$\mathbf{CIRC}[\theta;P_1>P_2>P_3;Z]$等价于
\begin{align*}
    \exists Q_{P_3}^1\exists Q_{P_3}^1\exists Q_Z^1\exists Q_{P_3}^2\exists Q_Z^2\exists Q_Z^3\mathbf{SM}[\psi;P_1,P_2,P_3,Q^1_{P_2},Q^1_{P_3},Q^{1}_{Z},Q^2_{P_3},Q^2_Z,Q^3_Z]
\end{align*}
\end{example}

从$Tr_v^p$的定义看出，这种翻译将会引入大量的辅助谓词，设第$j(1\leq j\leq k)$个优先级有$m_j$个极小化谓词，且总共有$n$个可变谓词，则引入的辅助谓词个数为$\Sigma^k_{j=1}(j-1)m_j+k(n+1)$。


\section{翻译优化}

上面介绍了在一般结构下，一阶限定理论到一阶稳定模型理论的翻译，然而在稳定模型语义下，当$\varphi$是一个$\Pi_1$-公式时，$\varphi$可以很容易的翻译成答集程序。因为一阶语句的任意性，消去存在量词成为了必要。

Eiter等人\cite{eiter1996normal}给出了经典逻辑下使用辅助谓词模拟存在量词，主要思想是：设$D$ 是一个有限的线性论域，$P$是$D$上的一个属性，定义$S$为$D$上的一个辅助属性满足$a$有性质$S$当且仅当存在比$a$小的$b$有性质$P$，因此，如果想知道是否有元素具有性质$P$，仅需要确定最小的元素是否具有性质$S$。
然而，在稳定模型语义下，要达到消去存在量词的效果，就需要对新引入的辅助谓词进行解释，章衡的翻译定义\ref{def_smfo2smufo}即是基于这样的思想提出的稳定模型语义下消去存在量词的方法。

根据定义\ref{def_smfo2smufo}，可以视为在有限结构下，一般的一阶稳定模型语义可以下降为答集程序。基于章衡的方法，本文同样优化限定理论翻译的消去存在量词的过程，使得其引入尽量少的辅助谓词和减小逻辑程序的规模。有如下的限定理论消去存在量词的翻译方法：

\begin{definition}\label{def_circ2sm_eliquat}
给定$\varphi$是形如$\forall\bar{x}\exists\bar{y}\theta(\bar{x},\bar{y})$ 的任意一阶语句，其中$\theta$是无量词的
否定范式，定义$\Gamma_{\exists}(\varphi;\sigma_i;\sigma_v)$是下述公式合取式的一阶全称闭包：
\begin{eqnarray}
% \nonumber to remove numbering (before each equation)
  \neg\neg S(\bar{x},\overline{min}) \label{form_circqe1}\\
  (succ(\bar{y},\bar{y}')~\wedge~S(\bar{x},\bar{y}'))~\vee~\theta^{\neg\neg}(\bar{x},\bar{y})~\rightarrow~S(\bar{x},\bar{y}) \label{form_circqe2}\\
  (succ(\bar{y},\bar{y}')~\wedge~W(\bar{x},\bar{y}'))~\vee~\theta^{\top\neg\neg}(\bar{x},\bar{y})~\rightarrow~W(\bar{x},\bar{y}) \label{form_circqe3}\\
  T(\bar{x},\overline{min})~\vee~\widetilde{\theta}(\bar{x},\overline{min}) \label{form_circqe4}\\
  succ(\bar{y},\bar{y}')~\rightarrow~(T(\bar{x},\bar{y})~\leftrightarrow~\widetilde{\theta}(\bar{x},\bar{y}')~\vee~T(\bar{x},\bar{y}')) \label{form_circqe5}\\
  succ(\bar{y},\bar{y}')~\wedge~\neg W(\bar{x},\bar{y}')~\wedge~W(\bar{x},\bar{y})~\rightarrow~(T(\bar{y},\overline{max})~\leftrightarrow~\widetilde{\theta}(\bar{x},\bar{y})) \label{form_circqe6}\\
  W(\bar{x},\overline{max})~\rightarrow~(T(\bar{y},\overline{max})~\leftrightarrow~\widetilde{\theta}(\bar{x},\overline{max})) \label{form_circqe7}\\
  \Gamma~\leftrightarrow~\bigwedge_{P\in\sigma_i}\forall\bar{x}(P(\bar(x))~\vee~\neg P(\bar{x})) \label{form_circqe8}
\end{eqnarray}
其中：
\begin{enumerate}
  \item $\theta^{\neg\neg}$是将$\theta$中所有形如$P(\overline{x})$($P$在$\sigma^i,1 \leq j \leq k,$的并集中)的公式替换为$\neg\neg P(\overline{x})$后所得到的公式；
  \item $\widetilde{\theta}$是将$\theta$进行如下转换：(i)将所有形如$(P(\overline{x})\rightarrow\Gamma)(P~\in~\sigma_i)$ 的公式替换为负文字$\neg P(\overline{x})$，(ii)将正文字$Q(\overline{x})(Q \in \sigma_v)$替换为$Q'(\overline{x})$，(iii)将形如$(Q'(\overline{x})\rightarrow \Gamma)$的公式替换为负文字$\neg Q'(\overline{x})$，$Q'$是不出现在$\theta$ 中的相对于$Q$的辅助谓词；
  \item $\theta^{\top\neg\neg}$是将$\widetilde{\theta}$中所有形如($P(\bar{x})~\rightarrow~\Gamma$)($P\in\sigma_i~\cup~\sigma_v$) 替换成$\top$。
\end{enumerate}
令$n$为序列$\bar{x}$与$\bar{y}$的长度之和，$\overline{succ}$描述$succ$所定义序被推广到$n$ 元组后的得到后继关系；
$\overline{min}$与$\overline{max}$分别表示$|\bar{y}|$元组$(min,...,min)$和$(max,...,max)$；$S,T,V,\Gamma$是新引入的辅助谓词，且不在$\varphi$中出现。
\end{definition}

对于上述定义中使用的辅助谓词和语句有如下的解释：
\begin{itemize}
  \item 谓词$S(x,y)$模拟$\varphi^{\neg\neg}$的存在量词；
  \item 谓词$W(x,y)$模拟$\tilde{\varphi}$的存在量词；
  \item 谓词$T(x,y)$模拟稳定模型语义下的$St(\varphi^*)$的存在量词。
\end{itemize}

\begin{proposition}
令$\varphi$是任意形如$\forall\bar{x}\exists\bar{y}\theta(\bar{x},\bar{y})$ 的一阶语句，$\sigma_i$是谓词常量元组，
则$\exists\sigma_v\exists S\exists W \exists T\exists\Gamma \mathbf{SM}[\Gamma_{\exists}(\varphi;\sigma_i);\sigma_i,\sigma_v,S,W,T,\Gamma]$ 在有穷结构下等价于$\mathbf{CIRC}[\varphi;\sigma_i]$，其中
$S,W,T,\Gamma$和$\sigma'_v$是由$\Gamma_{\exists}$ 引入的新谓词。
\end{proposition}


上述的优化过程整合个定义\ref{def_parallelcirc2sm} 的翻译$Tr_v$和定义\ref{def_smfo2smufo}的翻译$Tr_{QE}$。
这样就有两种消去存在量词的方法，第一种是经过翻译$Tr_v$后，存在量词仍然保存在语句中，然后在稳定模型语义下运用翻译$Tr_{QE}$消去存在量词；第二种方法是直接运用翻译优化$\Gamma_{\exists}$。

下面分析翻译优化的优化程度，通常用辅助谓词的数量来衡量，一个理论的规模被定义为联结词和原子的数量，除去共有的辅助谓词集$\Gamma$和$\sigma'_v$，第一种方法引入了4个辅助谓词，第二种方法引入了3 个辅助谓词。例如，设原本限定问题的规模为$n$，则第一种方法翻译后的规模为$10\times n$，第二种方法的规模为$6\times n$，随后，两种方法都需要继续迭代地使用翻译$Tr_{QE}$，随着迭代的次数增加，上述翻译优化方法将会减少$25\%$的辅助谓词，逻辑程序的大小将会减小$40\%$。

%翻译优化$\Gamma_{\exists}$适用于带可变谓词的并行限定，我们可以根据$Tr_v^p$将其扩展该翻译优化，使其适用于带可变谓词的优先级谓词。

\section{可译性}\label{sec_algorithm}

根据一阶限定理论到稳定语义下的一阶语言的可译性分析，得到如图\ref{fig_translate}所示的转化关系。


从图中可以看到主要存在如下的几种翻译途径：
\begin{enumerate}
  \item 一阶限定理论到一阶稳定理论（$CIRC[FO]~\Rightarrow~SM[FO]$），这一翻译可以根据定理\ref{pro_parallelcirc2sm}和定理\ref{pro_prioritycirc2sm}，这个翻译是在任意结构下都成立的；
  \item 一阶稳定理论到全称一阶稳定理论（$SM[FO]~\Rightarrow~SM[UFO]$），可以根据定义\ref{def_smfo2smufo}，这个翻译在有穷结构下是等价的；
  \item 一阶限定理论到全称一阶限定理论（$CIRC[FO]~\Rightarrow~CIRC[UFO]$），这一过程仍然没有充分的理论依据；
  \item 全称一阶限定理论到全称一阶稳定理论（$CIRC[UFO]~\Rightarrow~SM[UFO]$），这一过程同样没有充分的理论依据。
  \item 全称一阶限定理论通过加事实到加事实后的全称一阶稳定理论，实际意义即为命题限定理论的翻译，可以根据文献\cite{janhunen2004capturing}的并行限定求解理论依据、文献\cite{oikarinen2008implementing}的优先级限定求解依据和一个求解器的实现CIRC2DLP\cite{oikarinen2005circ2dlp}了解具体地做法。
  \item 一阶限定理论到全称一阶稳定理论（$CIRC[FO]~\Rightarrow~SM[UFO]$），对应翻译优化定义\ref{def_circ2sm_eliquat}，这一翻译在有穷结构下是等价的。
\end{enumerate}

\begin{figure}
  \center
  \includegraphics[width=0.9\textwidth]{img/translate.jpg}\\
  \caption{可译性关系图}\label{fig_translate}
\end{figure}

根据以上的翻译方法，本文总结了如下带可变谓词常元的一阶限定理论的计算方法，分为如下四个步骤：
\begin{enumerate}
  \item 将输入语句转换为否定范式和前束范式；
  \item 应用翻译优化$\Gamma_{\exists}$消去一层存在量词；
  \item 应用存在量词消去$Tr_{QE}$递归消去语句的所有存在量词，得到逻辑程序；
  \item 对每一个固定的谓词常元和可变的谓词常元加语句$\forall\bar{x}(P(\bar{x})\vee\neg P(\bar{x}))$。
\end{enumerate}

需要注意的是，在翻译$Tr_v$、$Tr_v^p$和$\Gamma_{\exists}$中，本章均没有提到对于函词常元的处理，因为可以很简单地使用谓词变元模拟函词变元，根据\cite{zhang2011translating}，稳定模型语义下，一个全称的二阶语句通过引入新的辅助谓词，可以翻译为一个一阶语句，因此，带有可变的函词常元的限定理论在理论上是可以被计算的，特别地，可变的个体常元通过添加一阶存在量词，可以被个体常元模拟。
%求解器的工作方式是，首先将输入的一阶限定理论“编译”成为逻辑程序，然后将该程序和问题实例的数据交给回答集求解器由回答集求解器求出问题实例的稳定模型，该稳定模型即为一阶限定理论的模型。


%\section{计算限定理论}

%对于任意一阶语句$\varphi$，我们首先使用第三章翻译优化理论定义将最外层的存在量词块消去，这样翻译后的语句均在稳定模型语义下，再根据第二章提到的章衡的消去存在量词的定义，将仍包含存在量词的语句消去存在量词，

\section{本章小结}

本章对一阶限定理论$\mathbf{CIRC}[FO]$和一阶稳定理论$\mathbf{SM}[FO]$之间可翻译方法作了深入的研究，具体地，本章得到了如下的结果：

一方面，在一般结构下，存在一阶并行限定理论和优先级限定理论到一阶稳定模型语义下的翻译，这一翻译有助于理解清晰限定理论与稳定理论之间的关系，这样的翻译也为回答集求解器计算一阶限定理论提供了理论基础与技术途径。

另一方面，本章给出了翻译过程中的一个优化，即从一阶限定理论到一阶稳定理论的一个存在量词消去，该方法引入更少的辅助谓词，同时分析了该量词消去算法在理论上会有良好的效果。
